# 项目整合海洋生物智能助手功能

# 1. 后端功能实现

## 1.1 配置pom文件

~~~ xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.gec</groupId>
    <artifactId>mrsp</artifactId>
    <version>1.0-SNAPSHOT</version>

    <!-- 指定spring boot父工程 -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.6</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <druid.version>1.2.9</druid.version>
        <mybatis-spring-boot-starter.version>3.0.3</mybatis-spring-boot-starter.version>
        <mysql-connector.version>8.0.29</mysql-connector.version>
        <mybatis-plus.version>3.5.6</mybatis-plus.version>
        <mybatis.version>3.5.16</mybatis.version>
        <!-- LangChain4j版本号，使用变量便于统一管理 -->
        <langchain4j.verion>1.0.0-beta1</langchain4j.verion>
    </properties>


    <dependencies>

        <!-- Spring Boot Web Starter -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>${mybatis.version}</version>
        </dependency>

        <!--集成druid连接池-->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
            <version>${druid.version}</version>
        </dependency>
        <!--Mysql数据库驱动-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>${mysql-connector.version}</version>
        </dependency>

        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-spring-boot3-starter</artifactId>
            <version>${mybatis-plus.version}</version>
        </dependency>

        <!-- MyBatis-Plus -->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus</artifactId>
            <version>${mybatis-plus.version}</version>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <!-- LangChain4j 核心依赖 -->
        <dependency>
            <groupId>dev.langchain4j</groupId>
            <artifactId>langchain4j</artifactId>
            <version>${langchain4j.verion}</version>
        </dependency>
        <!-- 向量存储 -->
        <dependency>
            <groupId>dev.langchain4j</groupId>
            <artifactId>langchain4j-embeddings-all-minilm-l6-v2</artifactId>
            <version>${langchain4j.verion}</version>
        </dependency>

        <dependency>
            <groupId>dev.langchain4j</groupId>
            <artifactId>langchain4j-open-ai-spring-boot-starter</artifactId>
            <version>${langchain4j.verion}</version>
        </dependency>
        <dependency>
            <groupId>dev.langchain4j</groupId>
            <artifactId>langchain4j-community-dashscope-spring-boot-starter</artifactId>
            <version>${langchain4j.verion}</version>
            <exclusions>
                <exclusion>
                    <groupId>org.slf4j</groupId>
                    <artifactId>slf4j-simple</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <!-- Spring Boot Maven 插件，用于打包和运行 Spring Boot 应用 -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>




</project>
~~~

## 核心组件实现

### RagConfiguration类

这个配置类是RAG（Retrieval-Augmented Generation，检索增强生成）系统的核心配置组件，主要负责：

#### 核心作用

1. **模型配置**：配置通义千问大语言模型用于生成回答
2. **向量化配置**：配置嵌入模型将文本转换为向量
3. **存储配置**：配置向量存储用于相似性检索
4. **系统初始化**：统一管理RAG系统的启动和配置验证

#### RagConfiguration完整代码

~~~ java
package com.gec.marine.config;

import com.gec.marine.properties.QwenProperties;
import dev.langchain4j.community.model.dashscope.QwenEmbeddingModel;
import dev.langchain4j.data.segment.TextSegment;
import dev.langchain4j.model.embedding.EmbeddingModel;
import dev.langchain4j.store.embedding.EmbeddingStore;
import dev.langchain4j.store.embedding.inmemory.InMemoryEmbeddingStore;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * RAG（Retrieval-Augmented Generation）系统核心配置类
 *
 * 作用概述：
 * 1. 配置和初始化通义千问大语言模型
 * 2. 配置向量嵌入模型用于文本向量化
 * 3. 配置向量存储组件用于相似性检索
 * 4. 提供RAG系统运行所需的核心组件Bean
 *
 * RAG工作流程：
 * 用户查询 -> 向量化(EmbeddingModel) -> 相似性检索(EmbeddingStore) ->
 * 检索到的上下文 + 用户问题 -> 大语言模型生成回答(ChatLanguageModel)
 *
 * @author Your Name
 * @version 1.0
 * @since 2024-01-01
 */
@Configuration
public class RagConfiguration {

    /**
     * 日志记录器，用于记录配置初始化过程和运行状态
     */
    private static final Logger logger = LoggerFactory.getLogger(RagConfiguration.class);

    /**
     * 通义千问相关配置属性
     * 包含API密钥、模型名称、温度参数、最大token数等配置信息
     */
    @Autowired
    private QwenProperties qwenProperties;


    /**
     * 配置文本嵌入模型Bean
     *
     * 作用：
     * - 将文本转换为高维向量表示
     * - 用于计算文本之间的语义相似性
     * - 支持用户查询的向量化和文档库的向量化
     *
     * 工作原理：
     * 1. 接收文本输入（用户问题或文档片段）
     * 2. 使用预训练的嵌入模型将文本转换为向量
     * 3. 向量可用于后续的相似性计算和检索
     *
     * @return EmbeddingModel 文本嵌入模型实例
     */
    @Bean
    public EmbeddingModel embeddingModel() {
        logger.info("初始化通义千问嵌入模型: {}", qwenProperties.getEmbeddingModel());

        return QwenEmbeddingModel.builder()
                .apiKey(qwenProperties.getApiKey())                    // API访问密钥
                .modelName(qwenProperties.getEmbeddingModel())         // 嵌入模型名称
                .build();
    }

    /**
     * 配置向量存储Bean
     *
     * 作用：
     * - 存储文档片段及其对应的向量表示
     * - 提供基于向量相似性的快速检索功能
     * - 支持添加、删除、查询等向量操作
     *
     * 存储结构：
     * - TextSegment: 文本片段，包含原始文本和元数据
     * - Vector: 对应的向量表示
     * - 支持基于余弦相似度等算法进行相似性搜索
     *
     * 注意：InMemoryEmbeddingStore为内存存储，应用重启后数据丢失
     * 生产环境建议使用持久化存储如Pinecone、Weaviate等
     *
     * @return EmbeddingStore<TextSegment> 向量存储实例
     */
    @Bean
    public EmbeddingStore<TextSegment> embeddingStore() {
        logger.info("初始化内存向量存储");
        return new InMemoryEmbeddingStore<>();
    }

    /**
     * 系统初始化后的回调方法
     *
     * 作用：
     * - 在所有Bean初始化完成后执行
     * - 记录系统配置信息用于调试和监控
     * - 验证配置的正确性
     *
     * 安全考虑：
     * - API密钥只显示前10位字符，后续用***替代
     * - 避免在日志中完整暴露敏感信息
     */
    @PostConstruct
    public void initializeSystem() {
        logger.info("RAG系统配置初始化完成");

        // 安全地记录API密钥（只显示前10位）
        String maskedApiKey = qwenProperties.getApiKey().substring(0, 10) + "***";
        logger.info("API Key: {}", maskedApiKey);

        // 记录模型配置信息
        logger.info("Chat Model: {}", qwenProperties.getChatModel());
        logger.info("Embedding Model: {}", qwenProperties.getEmbeddingModel());
        logger.info("Temperature: {}", qwenProperties.getTemperature());
        logger.info("Max Tokens: {}", qwenProperties.getMaxTokens());

        // 系统状态确认
        logger.info("RAG系统各组件配置完成，可以接受查询请求");
    }
}
~~~

### QwenProperties类

#### QwenProperties类概述

这个配置属性类是通义千问API集成的核心配置管理组件，主要负责：

#### 核心作用

1. **外部化配置**：将API配置从代码中分离，支持不同环境的灵活配置
2. **类型安全**：提供强类型的配置属性，避免配置错误
3. **默认值管理**：为各配置项提供合理的默认值
4. **配置验证**：通过注解确保配置值的有效性

![image-20250616002342235](../../../海大springboot+ai实训课程/9、springboot整合ai功能/assets/image-20250616002342235.png)

#### QwenProperties完整代码

~~~ java
package com.gec.marine.properties;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;


/**
 * 通义千问API配置属性类
 *
 * 概述：
 * 该类用于管理deepseek大语言模型的各项配置参数，通过Spring Boot的
 * @ConfigurationProperties机制从配置文件中自动绑定配置值。
 *
 * 主要作用：
 * 1. 统一管理deepseeAPI的配置参数
 * 2. 提供配置的默认值和类型安全保障
 * 3. 支持外部化配置，便于不同环境的配置管理
 * 4. 实现配置的集中化管理和维护
 *
 * 配置文件示例（application.yml）：
 * qwen:
 *   api-key: "your-api-key-here"
 *   chat-model: "qwen-plus"
 *   embedding-model: "text-embedding-v1"
 *   temperature: 0.3
 *   max-tokens: 2000
 *
 * @author Your Name
 * @version 1.0
 * @since 2024-01-01
 */
@Component
@ConfigurationProperties(prefix = "qwen")
public class QwenProperties {

    /**
     * 通义千问API访问密钥
     *
     * 作用：
     * - 用于身份验证和API访问授权
     * - 确保只有授权用户才能调用通义千问服务
     *
     * 获取方式：
     * - 访问阿里云通义千问控制台
     * - 创建应用并获取对应的API Key
     *
     * 安全注意事项：
     * - 该密钥具有计费功能，请妥善保管
     * - 不要在代码中硬编码，应通过配置文件或环境变量设置
     * - 建议定期轮换API密钥以保证安全性
     */
    private String apiKey;

    /**
     * 聊天对话模型名称
     *
     * 可选模型：
     * - qwen-turbo: 超快响应，适合简单对话场景
     * - qwen-plus: 平衡性能和效果，推荐日常使用（默认）
     * - qwen-max: 顶级效果，适合复杂推理任务
     * - qwen-max-longcontext: 支持长文本上下文的高级模型
     *
     * 选择建议：
     * - 简单问答：qwen-turbo
     * - 通用场景：qwen-plus
     * - 复杂任务：qwen-max
     * - 长文档处理：qwen-max-longcontext
     */
    private String chatModel = "qwen-plus";

    /**
     * 文本嵌入向量模型名称
     *
     * 可选模型：
     * - text-embedding-v1: 通用文本嵌入模型（默认）
     * - text-embedding-v2: 升级版嵌入模型，效果更佳
     *
     * 作用：
     * - 将文本转换为高维度向量表示
     * - 用于计算文本之间的语义相似性
     * - 支持多语言文本的向量化处理
     *
     * 应用场景：
     * - 文档检索和相似性匹配
     * - 语义搜索和推荐系统
     * - 文本聚类和分类任务
     */
    private String embeddingModel = "text-embedding-v1";

    /**
     * 生成文本的随机性控制参数（温度值）
     *
     * 取值范围：0.0 - 1.0
     *
     * 参数说明：
     * - 0.0-0.3: 保守生成，输出更确定和一致
     * - 0.3-0.7: 平衡创造性和一致性（推荐范围）
     * - 0.7-1.0: 高创造性，输出更多样化但可能不够稳定
     *
     * 应用指导：
     * - 事实性回答：使用较低温度（0.1-0.3）
     * - 创意写作：使用中等温度（0.5-0.7）
     * - 头脑风暴：使用较高温度（0.7-0.9）
     *
     * 默认值：0.3（适合大多数问答场景）
     */
    private Float temperature = 0.3f;

    /**
     * 单次生成的最大Token数量限制
     *
     * Token说明：
     * - Token是文本处理的基本单位，大致相当于一个词或字符
     * - 中文：1个汉字 ≈ 1-2个Token
     * - 英文：1个单词 ≈ 1-2个Token
     *
     * 取值建议：
     * - 简短回答：500-1000
     * - 常规对话：1000-2000（默认）
     * - 长文本生成：2000-4000
     * - 文章写作：4000-8000
     *
     * 注意事项：
     * - 更大的Token数会消耗更多API调用费用
     * - 某些模型对最大Token数有上限限制
     * - 建议根据实际需求合理设置
     */
    private Integer maxTokens = 2000;

    /**
     * 获取API密钥
     *
     * @return String API访问密钥
     */
    public String getApiKey() {
        return apiKey;
    }

    /**
     * 设置API密钥
     *
     * @param apiKey API访问密钥
     */
    public void setApiKey(String apiKey) {
        this.apiKey = apiKey;
    }

    /**
     * 获取聊天模型名称
     *
     * @return String 当前配置的聊天模型名称
     */
    public String getChatModel() {
        return chatModel;
    }

    /**
     * 设置聊天模型名称
     *
     * @param chatModel 聊天模型名称
     */
    public void setChatModel(String chatModel) {
        this.chatModel = chatModel;
    }

    /**
     * 获取嵌入模型名称
     *
     * @return String 当前配置的嵌入模型名称
     */
    public String getEmbeddingModel() {
        return embeddingModel;
    }

    /**
     * 设置嵌入模型名称
     *
     * @param embeddingModel 嵌入模型名称
     */
    public void setEmbeddingModel(String embeddingModel) {
        this.embeddingModel = embeddingModel;
    }

    /**
     * 获取温度参数值
     *
     * @return Float 当前配置的温度值
     */
    public Float getTemperature() {
        return temperature;
    }

    /**
     * 设置温度参数值
     *
     * @param temperature 温度值（0.0-1.0）
     */
    public void setTemperature(Float temperature) {
        this.temperature = temperature;
    }

    /**
     * 获取最大Token数限制
     *
     * @return Integer 当前配置的最大Token数
     */
    public Integer getMaxTokens() {
        return maxTokens;
    }

    /**
     * 设置最大Token数限制
     *
     * @param maxTokens 最大Token数
     */
    public void setMaxTokens(Integer maxTokens) {
        this.maxTokens = maxTokens;
    }

    /**
     * 重写toString方法，用于调试和日志输出
     * 注意：为了安全考虑，API密钥进行了脱敏处理
     *
     * @return String 对象的字符串表示
     */
    @Override
    public String toString() {
        return "QwenProperties{" +
                "apiKey='" + (apiKey != null ? apiKey.substring(0, Math.min(apiKey.length(), 10)) + "***" : "null") + '\'' +
                ", chatModel='" + chatModel + '\'' +
                ", embeddingModel='" + embeddingModel + '\'' +
                ", temperature=" + temperature +
                ", maxTokens=" + maxTokens +
                '}';
    }
}
~~~

### RagProperties类

#### RagProperties类概述

这个配置属性类是RAG系统检索环节的核心参数管理器，专门负责控制文档检索的质量和效率。

#### 核心作用

1. **检索数量控制**：限制返回结果数量，平衡质量与性能
2. **质量阈值管理**：过滤低相关性文档，确保上下文质量
3. **文档分块策略**：优化文档切分粒度，提高检索精度
4. **性能优化配置**：通过参数调优实现最佳检索效果

#### RagProperties完整代码

~~~ java
package com.gec.marine.properties;


import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;


/**
 * RAG系统检索配置属性类
 *
 * 概述：
 * 该类专门管理RAG（Retrieval-Augmented Generation）系统中检索环节的核心参数，
 * 这些参数直接影响文档检索的质量、准确性和性能表现。
 *
 * 主要作用：
 * 1. 控制检索结果的数量和质量阈值
 * 2. 管理文档分块处理的粒度
 * 3. 优化检索性能和准确性的平衡
 * 4. 支持不同场景下的检索策略调整
 *
 * RAG检索流程：
 * 用户查询 → 查询向量化 → 相似性检索(maxResults条结果) →
 * 过滤低分结果(minScore阈值) → 构建上下文 → 生成回答
 *
 * 配置文件示例（application.yml）：
 * rag:
 *   max-results: 3
 *   min-score: 0.5
 *   chunk-size: 500
 *
 * @author Your Name
 * @version 1.0
 * @since 2024-01-01
 */
@Component
@ConfigurationProperties(prefix = "rag")
public class RagProperties {


    private Integer maxResults = 3;
    private Double minScore = 0.5;
    private Integer chunkSize = 500;

    /**
     * 获取最大检索结果数量
     *
     * @return Integer 当前配置的最大结果数
     */
    public Integer getMaxResults() {
        return maxResults;
    }

    /**
     * 设置最大检索结果数量
     *
     * @param maxResults 最大结果数量，建议值：1-10
     */
    public void setMaxResults(Integer maxResults) {
        this.maxResults = maxResults;
    }

    /**
     * 获取相似性得分最小阈值
     *
     * @return Double 当前配置的最小得分阈值
     */
    public Double getMinScore() {
        return minScore;
    }

    /**
     * 设置相似性得分最小阈值
     *
     * @param minScore 最小得分阈值，取值范围：0.0-1.0
     */
    public void setMinScore(Double minScore) {
        this.minScore = minScore;
    }

    /**
     * 获取文档分块大小
     *
     * @return Integer 当前配置的分块字符数
     */
    public Integer getChunkSize() {
        return chunkSize;
    }

    /**
     * 设置文档分块大小
     *
     * @param chunkSize 分块字符数，建议值：300-1000
     */
    public void setChunkSize(Integer chunkSize) {
        this.chunkSize = chunkSize;
    }

    /**
     * 重写toString方法，便于调试和日志输出
     *
     * @return String 对象的字符串表示
     */
    @Override
    public String toString() {
        return "RagProperties{" +
                "maxResults=" + maxResults +
                ", minScore=" + minScore +
                ", chunkSize=" + chunkSize +
                '}';
    }

    /**
     * 验证配置参数的合理性
     * 用于在应用启动时检查配置的有效性
     *
     * @return boolean 配置是否有效
     */
    public boolean isValid() {
        return maxResults != null && maxResults > 0 &&
                minScore != null && minScore >= 0.0 && minScore <= 1.0 &&
                chunkSize != null && chunkSize > 0;
    }

    /**
     * 获取建议的重叠大小（分块大小的10%）
     * 用于文档分块时保持上下文连续性
     *
     * @return Integer 建议的重叠字符数
     */
    public Integer getRecommendedOverlapSize() {
        return Math.max(50, chunkSize / 10);
    }
}
~~~

##### 1. `maxResults`：最大检索结果数量

是什么？

表示：从向量数据库中**最多取出几条相似文档**用于回答问题。

举例：

假设你问：“阿里云 API Key 如何审核？”

- 如果 `maxResults = 3`，RAG 会从文档中找出**最相关的 3 段文本**作为上下文供大模型参考。
- 设置太小，信息不够；太大，则占用太多 Token，可能影响效率。

推荐：

一般设置为 **3~5**，能保证**信息够用又不会太臃肿**。

##### 2. `minScore`：相似度最低得分阈值

是什么？

表示：只有相似度高于这个分数的文档片段，才会被保留下来作为上下文。

- 相似度用的是 **余弦相似度**，值在 0～1 之间，越接近 1 表示越相关。

举例：

你问：“API 密钥审核流程”
 系统从向量库中检索了 10 段文档，只有 3 段相似度大于 `0.5`，系统就只保留这 3 段。

推荐：

- `0.7~0.8`：严格匹配（适合医疗、法律等）
- `0.5~0.6`：通用问答（推荐默认）
- `0.3~0.4`：探索型问答，宽松但可能引入噪声

##### 3. `chunkSize`：文档分块大小（单位：字符）

是什么？

把长文档**按指定字符数切分成多个小段**，用于向量化入库和检索。

举例：

假设你有一段 3000 字的文章：

- 设置 `chunkSize = 500`，系统就会将文章分成 6 段（每段 500 字）；
- 设置太小（如 200），切得太碎，模型可能看不到上下文；
- 设置太大（如 1500），段内信息多，但检索精度可能下降。

推荐：

- 中文：建议设置为 **400~600**
- 英文：可适当设置大一些，因为词比字符少

### KnowledgeBaseService类

#### 1. KnowledgeBaseService类概述

- 这是一个RAG系统的知识库数据提供服务类，用于**海洋生物**的结构化知识数据。我来为您详细解析并添加完整的注释：

#### 2. 完整代码

~~~ java
package com.gec.marine.service;

import org.springframework.stereotype.Service;

@Service
public class KnowledgeBaseService {

    /**
     * 获取海洋生物相关的知识库数据
     * 在实际生产环境中，这些数据通常来自数据库、文档文件或外部API
     */
    public String[] getMarineBiologyKnowledgeBase() {
        return new String[]{
                """
            # 鲸类生物分类和特征
            
            ## 基本分类：
            - 鲸类分为须鲸亚目和齿鲸亚目两大类
            - 须鲸包括蓝鲸、座头鲸、灰鲸等，以磷虾和小鱼为食
            - 齿鲸包括抹香鲸、虎鲸、海豚等，具有回声定位能力
            
            ## 生物特征：
            * 蓝鲸是地球上最大的动物，体长可达30米，重达200吨
            * 鲸类是哺乳动物，用肺呼吸，体温恒定，胎生哺乳
            * 鲸类的智商很高，具有复杂的社会结构和沟通方式
            
            ## 行为特点：
            - 多数鲸类具有长距离迁徙的习性
            - 使用声纳系统进行导航和觅食
            - 群体生活，具有复杂的社会等级制度
            """,
                """
            # 珊瑚礁生态系统
            
            ## 基本概念：
            * 珊瑚礁是海洋中生物多样性最丰富的生态系统之一
            * 由珊瑚虫分泌的石灰质骨骼堆积形成
            * 主要分布在热带和亚热带浅海区域
            
            ## 生态价值：
            - 为25%的海洋鱼类提供栖息地和繁殖场所
            - 大堡礁是世界最大的珊瑚礁系统，长达2300公里
            - 珊瑚虫与藻类共生，形成互惠关系
            
            ## 面临威胁：
            * 珊瑚白化现象是由海水温度升高引起的
            * 珊瑚礁面临污染、过度捕捞和气候变化的威胁
            * 海洋酸化对珊瑚骨骼形成造成影响
            
            ## 保护措施：
            - 建立海洋保护区
            - 控制沿岸开发和污染
            - 开展珊瑚礁修复项目
            """,
                """
            # 深海生物适应性特征
            
            ## 深海环境特点：
            * 高压环境（每下降10米压力增加1个大气压）
            * 低温环境（通常2-4°C）
            * 无光环境（阳光无法穿透）
            * 食物稀少（依赖海洋雪和化学合成）
            
            ## 生物适应机制：
            - 生物发光：许多深海生物能产生生物光用于交流和捕食
            - 巨型现象：深海中某些生物比浅海同类体型更大
            - 代谢缓慢：适应食物稀少的环境，能量消耗极低
            - 压力适应：体内充满液体，没有充气器官
            
            ## 特殊器官和功能：
            * 电鳗的发电器官，可产生高达600伏电压
            * 琵琶鱼的发光诱饵，用于吸引猎物
            * 巨嘴鸟鱼的可伸缩下颚，适应大型猎物
            
            ## 深海生态系统：
            - 深海热泉生物群落：依靠化学合成而非光合作用生存
            - 深海探索仍在进行中，新物种不断被发现
            - 深海食物链复杂，依赖垂直迁移和有机物沉降
            """,
                """
            # 海洋鱼类分类和习性
            
            ## 基本分类：
            * 软骨鱼类：鲨鱼、鳐鱼等，骨骼由软骨组成
            * 硬骨鱼类：占海洋鱼类的95%以上，骨骼钙化坚硬
            
            ## 生活习性分类：
            - 洄游性鱼类：如金枪鱼、三文鱼，具有长距离迁徙能力
            - 领域性鱼类：如小丑鱼，在固定区域内生活
            - 深海鱼类：适应高压低温环境
            - 浅海鱼类：生活在阳光充足的海域
            
            ## 特殊能力：
            * 群游行为：许多鱼类成群游泳以增加生存几率
            * 鲨鱼拥有敏锐的感官系统，能感知微弱的电场
            * 部分鱼类具有变色能力，如比目鱼、某些热带鱼
            * 电鱼类可以产生电场用于导航和捕食
            
            ## 生态和经济价值：
            - 海洋鱼类是重要的食物资源和生态链环节
            - 维持海洋生态平衡的关键物种
            - 支撑全球渔业经济发展
            """,
                """
            # 海洋无脊椎动物
            
            ## 主要分类：
            * 软体动物：章鱼、乌贼、海螺、牡蛎等
            * 甲壳动物：螃蟹、龙虾、虾类、藤壶等
            * 棘皮动物：海星、海胆、海参、海百合等
            * 腔肠动物：水母、海葵、珊瑚等
            
            ## 特殊能力和特征：
            - 章鱼是最聪明的无脊椎动物，具有学习和记忆能力
            - 水母存在已超过5亿年，是地球上最古老的生物之一
            - 海星具有再生能力，失去的肢体可以重新长出
            - 乌贼具有高度发达的色素细胞，可快速变色
            
            ## 生态功能：
            * 海洋食物链的重要环节
            * 海底清洁工（如海参、海胆）
            * 滤食性动物（如牡蛎、海绵）净化海水
            
            ## 经济价值：
            - 许多海洋无脊椎动物具有重要的经济价值
            - 海鲜产业的重要组成部分
            - 医药和生物技术研究的宝贵资源
            """,
                """
            # 海洋植物和藻类
            
            ## 主要分类：
            * 海藻分为绿藻、褐藻、红藻三大类
            * 浮游植物：硅藻、甲藻、蓝藻等
            * 海草：真正的海洋维管植物，具有根、茎、叶
            
            ## 形态特征：
            - 巨藻是世界上最大的海藻，可长达60米
            - 硅藻具有精美的硅质细胞壁
            - 海带具有固着器、柄部和叶片
            
            ## 生态功能：
            * 浮游植物是海洋食物链的基础生产者
            * 海洋植物产生地球约70%的氧气
            * 海洋植物在碳循环中发挥关键作用
            * 为海洋动物提供栖息地和食物来源
            
            ## 经济和科学价值：
            - 海带养殖是重要的海洋农业活动
            - 藻类提取物广泛用于食品、医药和化工
            - 生物燃料和碳汇研究的重要对象
            
            ## 环境指示作用：
            * 藻类分布反映海洋环境质量
            * 赤潮现象与营养盐过量相关
            - 海草床退化指示海洋生态健康状况
            """,
                """
            # 海洋保护和可持续发展
            
            ## 保护措施：
            * 建立海洋保护区保护珍稀海洋生物
            * 控制过度捕捞，实施渔业配额制度
            * 减少海洋塑料污染和化学污染
            * 应对气候变化对海洋生态的影响
            
            ## 重点保护对象：
            - 保护濒危物种如海龟、海豚、鲸鱼等
            - 关键栖息地如珊瑚礁、海草床、红树林
            - 洄游通道和繁殖区域
            
            ## 可持续利用：
            * 推广可持续海产品消费
            * 发展生态友好的海洋养殖业
            * 合理开发海洋可再生能源
            
            ## 科研和监测：
            - 开展海洋生物多样性研究和监测
            - 建立海洋生态系统健康评估体系
            - 利用遥感和人工智能技术监控海洋环境
            
            ## 国际合作：
            * 国际合作保护跨国界海洋生物
            * 建立全球海洋保护网络
            * 共享海洋科学研究成果
            
            ## 公众参与：
            - 教育公众提高海洋保护意识
            - 鼓励公民参与海洋保护行动
            - 建立海洋环保志愿者网络
            """
        };
    }

    /**
     * 获取常见海洋生物问题的标准答案
     */
    public String[] getFaqDatabase() {
        return new String[]{
                """
                Q: 鲸鱼是鱼类吗？
                A: * 不是，鲸鱼是哺乳动物
                   - 用肺呼吸，不是用鳃
                   - 胎生哺乳，而非产卵
                   - 体温恒定，属于温血动物
                   - 具有毛发（虽然很少）和哺乳腺
                """,
                """
                Q: 为什么珊瑚会白化？
                A: * 主要原因是海水温度升高
                   - 珊瑚虫排出体内的共生藻类
                   - 失去藻类后珊瑚失去颜色变白
                   - 长期白化会导致珊瑚死亡
                   - 其他因素：污染、酸化、紫外线增强
                """,
                """
                Q: 深海鱼为什么会发光？
                A: * 生物发光的多种用途：
                   - 吸引猎物：如琵琶鱼的发光诱饵
                   - 躲避天敌：通过光线迷惑捕食者
                   - 同种交流：识别同类和求偶信号
                   - 寻找配偶：在黑暗中定位伴侣
                   - 照明功能：帮助在黑暗中觅食
                """,
                """
                Q: 海星失去胳膊后还能活吗？
                A: * 可以，海星具有强大的再生能力
                   - 失去的肢体可以重新长出
                   - 甚至一个肢体可以长成新个体
                   - 再生过程需要数月到数年时间
                   - 这是棘皮动物的典型特征
                """,
                """
                Q: 章鱼有几个心脏？
                A: * 章鱼有3个心脏：
                   - 2个鳃心脏负责向鳃泵血
                   - 1个体心脏向身体其他部位供血
                   - 游泳时体心脏停止跳动
                   - 这就是章鱼偏爱爬行而非游泳的原因
                """,
                """
                Q: 海洋中最大的动物是什么？
                A: * 蓝鲸是地球上已知最大的动物
                   - 体长可达30米（约3层楼高）
                   - 体重可达200吨
                   - 心脏重达600公斤
                   - 舌头重达3吨
                   - 一次可吞食4吨磷虾
                """,
                """
                Q: 海龟如何导航？
                A: * 海龟利用多种导航方式：
                   - 地球磁场：感知磁场变化确定方向
                   - 星座导航：利用星星位置定位
                   - 海流模式：跟随固定的海流路线
                   - 化学信号：识别家乡海域的特殊气味
                   - 海水温度和盐度差异
                """,
                """
                Q: 什么是海洋酸化？
                A: * 海洋酸化的形成机制：
                   - 大气中CO2浓度增加
                   - 海洋吸收更多CO2
                   - CO2与海水反应形成碳酸
                   - 导致海水pH值下降
                   * 影响：
                   - 影响贝类和珊瑚的壳体形成
                   - 破坏海洋食物链平衡
                   - 威胁海洋生物多样性
                """
        };
    }

    /**
     * 获取海洋生物分类标签
     */
    public String[] getClassificationTags() {
        return new String[]{
                "# 哺乳动物",
                "* 鲸类 - 蓝鲸、座头鲸、抹香鲸、虎鲸、海豚",
                "* 鳍脚类 - 海豹、海狮、海象",
                "* 海牛类 - 海牛、儒艮",

                "# 鱼类",
                "* 软骨鱼 - 鲨鱼、鳐鱼、鳗鱼",
                "* 硬骨鱼 - 金枪鱼、鲑鱼、鲈鱼、比目鱼",

                "# 无脊椎动物",
                "* 软体动物 - 章鱼、乌贼、海螺、牡蛎",
                "* 甲壳动物 - 螃蟹、龙虾、虾类",
                "* 棘皮动物 - 海星、海胆、海参",
                "* 腔肠动物 - 水母、海葵、珊瑚",

                "# 海洋植物",
                "* 大型藻类 - 海带、紫菜、裙带菜",
                "* 浮游植物 - 硅藻、甲藻",
                "* 海草 - 鳗草、海菖蒲"
        };
    }
}
~~~

### MarineBiologyRagService

#### MarineBiologyRagService类概述

MarineBiologyRagService是一个基于Spring Boot的服务类，实现了系统的核心功能。该类集成了RAG（Retrieval-Augmented Generation）技术，结合DeepSeek AI模型，为用户提供海洋生物的服务。

主要特点

- **RAG技术集成**：结合向量检索和生成式AI，提供准确的知识问答
- **双模式支持**：支持标准响应和流式响应
- **智能记忆**：具备对话上下文记忆功能
- **向量化知识库**：将海洋生物知识转换为向量存储，支持语义搜索

#### 完整代码

~~~ java
package com.gec.marine.service;

import com.gec.marine.properties.RagProperties;
import dev.langchain4j.data.embedding.Embedding;
import dev.langchain4j.data.message.SystemMessage;
import dev.langchain4j.data.message.UserMessage;
import dev.langchain4j.data.segment.TextSegment;
import dev.langchain4j.model.chat.ChatLanguageModel;
import dev.langchain4j.model.chat.StreamingChatLanguageModel;
import dev.langchain4j.model.openai.OpenAiStreamingChatModel;
import dev.langchain4j.model.openai.OpenAiChatModel;
import dev.langchain4j.model.chat.response.ChatResponse;
import dev.langchain4j.model.embedding.EmbeddingModel;
import dev.langchain4j.model.input.Prompt;
import dev.langchain4j.rag.content.Content;
import dev.langchain4j.rag.content.retriever.ContentRetriever;
import dev.langchain4j.rag.content.retriever.EmbeddingStoreContentRetriever;
import dev.langchain4j.rag.query.Query;
import dev.langchain4j.store.embedding.EmbeddingStore;
import dev.langchain4j.store.embedding.EmbeddingSearchRequest;
import dev.langchain4j.store.embedding.EmbeddingSearchResult;
import dev.langchain4j.store.embedding.EmbeddingMatch;
import dev.langchain4j.service.TokenStream;
import dev.langchain4j.service.AiServices;
import dev.langchain4j.memory.ChatMemory;
import dev.langchain4j.memory.chat.MessageWindowChatMemory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
import reactor.core.publisher.Flux;
import jakarta.annotation.PostConstruct;

import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;

@Service
public class MarineBiologyRagService {

    private static final Logger logger = LoggerFactory.getLogger(MarineBiologyRagService.class);

    @Value("${deepseek.api-key}")
    private String deepseekApiKey;

    @Value("${deepseek.model:deepseek-chat}")
    private String deepseekModel;

    @Value("${deepseek.base-url:https://api.deepseek.com}")
    private String deepseekBaseUrl;

    @Value("${deepseek.timeout:60}")
    private Integer timeoutSeconds;

    @Value("${deepseek.max-tokens:4000}")
    private Integer maxTokens;

    @Value("${deepseek.temperature:0.3}")
    private Double temperature;

    // 海洋生物专家助手接口定义
    public interface MarineBiologyExpert {
        String chat(String message);
        TokenStream stream(String message);
    }

    private ChatLanguageModel chatModel;
    private StreamingChatLanguageModel streamingChatModel;
    private MarineBiologyExpert marineBiologyExpert;
    private ContentRetriever contentRetriever; // 内容检索器

    @Autowired
    private EmbeddingModel embeddingModel;

    @Autowired
    private EmbeddingStore<TextSegment> embeddingStore;

    @Autowired
    private KnowledgeBaseService knowledgeBaseService;

    @Autowired
    private RagProperties ragProperties;

    private boolean isInitialized = false;

    /**
     * 初始化DeepSeek聊天模型和海洋生物专家助手
     */
    @PostConstruct
    public void initializeModels() {
        try {
            logger.info("初始化DeepSeek聊天模型（标准+流式）...");

            if (deepseekApiKey == null || deepseekApiKey.trim().isEmpty() || deepseekApiKey.equals("your-deepseek-api-key-here")) {
                throw new IllegalStateException("DeepSeek API Key未配置或配置错误");
            }

            // 初始化标准聊天模型
            this.chatModel = OpenAiChatModel.builder()
                    .baseUrl(deepseekBaseUrl)
                    .apiKey(deepseekApiKey)
                    .modelName(deepseekModel)
                    .maxTokens(maxTokens)
                    .temperature(temperature)
                    .timeout(Duration.ofSeconds(timeoutSeconds))
                    .build();

            // 初始化流式聊天模型
            this.streamingChatModel = OpenAiStreamingChatModel.builder()
                    .baseUrl(deepseekBaseUrl)
                    .apiKey(deepseekApiKey)
                    .modelName(deepseekModel)
                    .maxTokens(maxTokens)
                    .temperature(temperature)
                    .timeout(Duration.ofSeconds(timeoutSeconds))
                    .build();

            // 初始化海洋生物知识库
            initializeMarineKnowledgeBase();

            // 创建海洋生物专家助手实例
            initializeMarineBiologyExpert();

            logger.info("DeepSeek模型和海洋生物专家助手初始化完成（支持标准和流式响应）");

        } catch (IllegalStateException e) {
            logger.error("DeepSeek配置错误: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            logger.error("DeepSeek模型初始化失败: {}", e.getMessage(), e);
            throw new RuntimeException("DeepSeek模型初始化失败", e);
        }
    }

    /**
     * 初始化海洋生物专家助手 - 集成RAG和聊天记忆
     */
    private void initializeMarineBiologyExpert() {
        try {
            // 1. 创建持久化聊天记忆
            ChatMemory chatMemory = MessageWindowChatMemory.withMaxMessages(20);

            // 2. 创建内容检索器 - 这是关键步骤
            this.contentRetriever = EmbeddingStoreContentRetriever.builder()
                    .embeddingStore(embeddingStore)
                    .embeddingModel(embeddingModel)
                    .maxResults(ragProperties.getMaxResults())
                    .minScore(ragProperties.getMinScore())
                    .build();

            // 3. 构建海洋生物专家助手，集成RAG功能
            this.marineBiologyExpert = AiServices.builder(MarineBiologyExpert.class)
                    // 设置标准聊天模型
                    .chatLanguageModel(chatModel)
                    // 设置流式聊天模型
                    .streamingChatLanguageModel(streamingChatModel)
                    // 配置聊天记忆
                    .chatMemory(chatMemory)
                    // 关键：添加内容检索器，实现RAG功能
                    .contentRetriever(contentRetriever)
                    .systemMessageProvider(s->buildSystemMessageString())
                    .build();

            logger.info("海洋生物专家助手（含RAG功能）初始化完成");
        } catch (Exception e) {
            logger.error("海洋生物专家助手初始化失败: {}", e.getMessage(), e);
            throw new RuntimeException("海洋生物专家助手初始化失败", e);
        }
    }

    /**
     * 构建海洋生物专家系统消息
     */
    private String buildSystemMessageString() {
        return """
        你是一位专业的海洋生物学专家，拥有丰富的海洋生物知识和研究经验，使用DeepSeek AI技术为用户提供准确的海洋生物相关咨询。

        ## 专业领域：
        1. **海洋生物分类**：鱼类、哺乳动物、无脊椎动物、海洋植物等
        2. **生态系统**：珊瑚礁、深海、海岸带、极地海洋等
        3. **生物行为**：觅食、繁殖、迁徙、社会行为等
        4. **保护现状**：濒危物种、保护措施、环境威胁等
        5. **科学研究**：最新发现、研究方法、观察技术等

        ## 回答规范：
        1. **科学准确性**：严格基于提供的参考信息和科学事实回答
        2. **专业性**：使用准确的科学术语，同时确保通俗易懂
        3. **详细性**：提供具体的数据、特征、分布等信息
        4. **结构化**：回答要有条理，适当使用分类和列举
        5. **教育性**：帮助用户了解海洋生物的奇妙世界
        6. **上下文感知**：记住之前的对话内容，提供连贯的专业指导
        
        ## 重要提醒：
        - 当用户提问时，会自动从海洋生物知识库检索相关信息
        - 优先使用检索到的准确科学信息回答
        - 如果检索信息不完整，明确说明知识局限性
        - 保持对话连贯性，记住用户之前提到的海洋生物话题
        - 鼓励海洋保护意识和科学探索精神
        
        请以专业、友好的方式回答用户关于海洋生物的问题，分享海洋世界的精彩知识。
        """;
    }

    /**
     * 处理海洋生物相关查询（RAG自动集成）
     */
    public String processQuery(String userQuery) {
        if (!isInitialized) {
            return "海洋生物知识库正在初始化中，请稍后再试...";
        }

        if (userQuery == null || userQuery.trim().isEmpty()) {
            return "请告诉我您想了解的海洋生物问题，我会为您提供专业的解答。";
        }

        try {
            logger.info("处理海洋生物查询: {}", userQuery);

            // 直接使用海洋生物专家助手（已集成RAG功能）
            String response = marineBiologyExpert.chat(userQuery);

            System.out.println(response);

            logger.info("成功处理查询，返回回答长度: {} 字符", response.length());
            return formatFinalResponse(response, userQuery);

        } catch (Exception e) {
            logger.error("处理查询时发生错误: {}", e.getMessage(), e);
            return "抱歉，系统暂时无法处理您的海洋生物问题。请稍后再试或参考海洋生物百科全书。";
        }
    }

    /**
     * 流式查询处理（RAG自动集成）
     */
    public Flux<String> processQueryStream(String userQuery) {
        if (!isInitialized) {
            return Flux.just("海洋生物知识库正在初始化中，请稍后再试...");
        }

        if (userQuery == null || userQuery.trim().isEmpty()) {
            return Flux.just("请告诉我您想了解的海洋生物问题，我会为您提供专业的解答。");
        }

        try {
            logger.info("开始流式处理海洋生物查询: {}", userQuery);

            // 直接使用海洋生物专家助手的stream方法（已集成RAG）
            TokenStream stream = marineBiologyExpert.stream(userQuery);

            return Flux.create(sink -> {
                sink.next("🐋 海洋生物专家回复：\n\n");

                stream
                        .onPartialResponse(partialResponse -> {
                            if (partialResponse != null && !partialResponse.trim().isEmpty()) {
                                try {
                                    String encodedResponse = new String(
                                            partialResponse.getBytes(StandardCharsets.UTF_8),
                                            StandardCharsets.UTF_8
                                    );
                                    sink.next(encodedResponse);
                                } catch (Exception e) {
                                    logger.warn("编码响应失败，使用原始内容: {}", e.getMessage());
                                    sink.next(partialResponse);
                                }
                            }
                        })
                        .onCompleteResponse(completeResponse -> {
                            String footer = buildResponseFooter(userQuery);
                            sink.next(footer);
                            sink.complete();
                        })
                        .onError(error -> {
                            logger.error("流式响应错误: {}", error.getMessage(), error);
                            sink.next("\n\n⚠️ 响应生成中断，请刷新重试");
                            sink.error(error);
                        })
                        .start();
            });

        } catch (Exception e) {
            logger.error("流式处理查询时发生错误: {}", e.getMessage(), e);
            return Flux.just(generateFallbackResponse(userQuery));
        }
    }



    /**
     * 系统启动时初始化海洋生物知识库向量数据
     */
    private void initializeMarineKnowledgeBase() {
        try {
            logger.info("开始初始化海洋生物知识库向量数据...");

            String[] marineKnowledgeBase = knowledgeBaseService.getMarineBiologyKnowledgeBase();
            String[] marineFaqBase = knowledgeBaseService.getFaqDatabase();

            // 处理主要海洋生物知识库
            for (int i = 0; i < marineKnowledgeBase.length; i++) {
                addKnowledgeToVectorStore(marineKnowledgeBase[i], "海洋生物知识库-" + (i + 1));
            }

            // 处理海洋生物FAQ数据库
            for (int i = 0; i < marineFaqBase.length; i++) {
                addKnowledgeToVectorStore(marineFaqBase[i], "海洋生物FAQ-" + (i + 1));
            }

            isInitialized = true;
            logger.info("海洋生物知识库初始化完成！共加载 {} 条知识条目",
                    marineKnowledgeBase.length + marineFaqBase.length);

        } catch (Exception e) {
            logger.error("海洋生物知识库初始化失败: {}", e.getMessage(), e);
            throw new RuntimeException("海洋生物知识库初始化失败", e);
        }
    }

    /**
     * 添加海洋生物知识到向量存储
     */
    private void addKnowledgeToVectorStore(String content, String source) {
        try {
            // 确保内容不为空且有意义
            if (content == null || content.trim().isEmpty()) {
                logger.warn("跳过空内容: {}", source);
                return;
            }

            TextSegment segment = TextSegment.from(content.trim());
            Embedding embedding = embeddingModel.embed(segment).content();
            embeddingStore.add(embedding, segment);
            logger.debug("已添加海洋生物知识条目: {} (长度: {})", source, content.length());
        } catch (Exception e) {
            logger.error("添加海洋生物知识条目失败 [{}]: {}", source, e.getMessage());
        }
    }

    /**
     * 构建响应尾部信息
     */
    private String buildResponseFooter(String userQuery) {
        return """
            
            ---
            🌊 海洋探索提醒：
            • 想了解更多海洋生物？访问海洋生物百科全书
            • 支持海洋保护：关注当地海洋保护组织
            • 科学研究合作：marine.research@example.com
            • 紧急海洋生物救助热线：1-800-MARINE-HELP
            
            🐠 让我们一起保护美丽的海洋世界！
            🔋 Powered by DeepSeek AI Marine Biology Expert
            """;
    }

    /**
     * 格式化最终响应
     */
    private String formatFinalResponse(String aiResponse, String userQuery) {
        return String.format("""
            🐋 海洋生物专家回复：
            
            %s
            
            ---
            🌊 海洋探索提醒：
            • 想了解更多海洋生物？访问海洋生物百科全书
            • 支持海洋保护：关注当地海洋保护组织
            • 科学研究合作：marine.research@example.com
            • 紧急海洋生物救助热线：1-800-MARINE-HELP
            
            🐠 让我们一起保护美丽的海洋世界！
            🔋 Powered by DeepSeek AI Marine Biology Expert
            """, aiResponse);
    }

    /**
     * 降级处理响应
     */
    private String generateFallbackResponse(String userQuery) {
        return String.format("""
            🐋 海洋生物专家（基础模式）：
            
            关于您的问题："%s"
            
            📚 基于海洋生物知识库的基础信息：
            • 海洋哺乳动物：鲸鱼、海豚、海豹等智慧生物
            • 鱼类多样性：从小丑鱼到大白鲨，超过3万种
            • 无脊椎动物：珊瑚、水母、章鱼等奇妙生物
            • 深海生物：发光鱼类、巨型鱿鱼等神秘物种
            • 海洋植物：海带、海草、浮游植物等生态基础
            
            🔄 获得完整专家服务：
            1. 稍后重试，AI专家系统正在恢复
            2. 刷新页面重新提问
            3. 查阅海洋生物百科全书获得详细信息
            
            📖 推荐资源：
            🌐 海洋生物百科：www.marinebiologyencyclopedia.com
            📱 海洋探索APP：搜索"Marine Life Explorer"
            🏛️ 参观当地海洋馆获得更直观的了解
            
            ⚡ 专家AI服务将在几分钟内恢复正常
            """, userQuery);
    }

    /**
     * 获取系统状态
     */
    public String getSystemStatus() {
        return String.format("""
            📊 海洋生物专家系统状态：
            • 初始化状态：%s
            • 海洋生物知识库条目：%d+
            • 最大检索结果：%d
            • 最小相似度：%.2f
            • DeepSeek模型：%s
            • 标准模型状态：%s
            • 流式模型状态：%s
            • 海洋生物专家助手状态：%s
            • RAG检索器状态：%s
            • 运行状态：正常 ✅
            • AI引擎：DeepSeek AI Marine Biology Expert
            • 专业领域：海洋生物学、生态学、保护生物学
            """,
                isInitialized ? "已完成" : "进行中",
                knowledgeBaseService.getMarineBiologyKnowledgeBase().length +
                        knowledgeBaseService.getFaqDatabase().length,
                ragProperties.getMaxResults(),
                ragProperties.getMinScore(),
                deepseekModel,
                chatModel != null ? "已连接" : "未连接",
                streamingChatModel != null ? "已连接" : "未连接",
                marineBiologyExpert != null ? "已初始化" : "未初始化",
                contentRetriever != null ? "已配置" : "未配置"
        );
    }

    /**
     * 清理资源和重置聊天记忆
     */
    public void resetChatMemory() {
        try {
            // 重新初始化海洋生物专家助手以清除聊天记忆
            initializeMarineBiologyExpert();
            logger.info("聊天记忆已重置，海洋生物知识RAG功能保持正常");
        } catch (Exception e) {
            logger.error("重置聊天记忆失败: {}", e.getMessage(), e);
        }
    }

    /**
     * 获取海洋生物专家助手实例
     */
    public MarineBiologyExpert getMarineBiologyExpert() {
        return marineBiologyExpert;
    }

    /**
     * 获取内容检索器实例
     */
    public ContentRetriever getContentRetriever() {
        return contentRetriever;
    }
}
~~~

2. 核心架构组件

2.1 AI模型组件

java

```java
private ChatLanguageModel chatModel;                    // 标准聊天模型
private StreamingChatLanguageModel streamingChatModel;  // 流式聊天模型
private FlightAssistant flightAssistant;               // AI助手接口
```

2.2 RAG组件

java

```java
private ContentRetriever contentRetriever;             // 内容检索器
private EmbeddingModel embeddingModel;                 // 嵌入模型
private EmbeddingStore<TextSegment> embeddingStore;    // 向量存储
```

2.3 配置组件

java

```java
@Value("${deepseek.api-key}")
private String deepseekApiKey;                         // API密钥
@Value("${deepseek.model:deepseek-chat}")
private String deepseekModel;                          // 模型名称
```

3. 核心方法详细解释

3.1 初始化方法

`initializeModels()` - 系统初始化入口

java

```java
@PostConstruct
public void initializeModels()
```

**作用**：

- 系统启动时自动执行的初始化方法
- 配置DeepSeek AI模型（标准版和流式版）
- 初始化知识库向量数据
- 创建AI助手实例

**关键步骤**：

1. 验证API Key配置
2. 构建标准和流式聊天模型
3. 调用知识库初始化
4. 创建集成RAG功能的AI助手

`initializeFlightAssistant()` - AI助手初始化

java

```java
private void initializeFlightAssistant()
```

**作用**：

- 创建具备RAG功能的AI助手
- 集成聊天记忆、内容检索、系统提示等功能

**核心实现**：



java

```java
this.flightAssistant = AiServices.builder(FlightAssistant.class)
    .chatLanguageModel(chatModel)
    .streamingChatLanguageModel(streamingChatModel)
    .chatMemory(chatMemory)
    .contentRetriever(contentRetriever)  // 关键：集成RAG功能
    .systemMessageProvider(chatMemoryId -> buildSystemMessageString())
    .build();
```

`initializeKnowledgeBase()` - 知识库向量化



java

```java
private void initializeKnowledgeBase()
```

**作用**：

- 将航班知识库和FAQ转换为向量表示
- 存储到向量数据库中，支持语义搜索

**处理流程**：

1. 获取知识库内容和FAQ数据
2. 逐条转换为TextSegment
3. 生成向量嵌入
4. 存储到EmbeddingStore

3.2 查询处理方法

`processQuery(String userQuery)` - 标准查询处理

java

```java
public String processQuery(String userQuery)
```

**作用**：

- 处理用户查询，返回完整答案
- 自动集成RAG检索和AI生成

**处理流程**：

1. 验证系统初始化状态
2. 输入验证和预处理
3. 调用AI助手（自动执行RAG检索）
4. 格式化最终响应

**关键特性**：

- RAG功能已自动集成，无需手动检索
- 支持对话上下文记忆
- 包含错误处理和降级方案

`processQueryStream(String userQuery)` - 流式查询处理

java

```java
public Flux<String> processQueryStream(String userQuery)
```

**作用**：

- 提供实时流式响应体验
- 支持逐字输出，提升用户体验

**实现原理**：

java

```java
TokenStream stream = flightAssistant.stream(userQuery);
return Flux.create(sink -> {
    stream.onPartialResponse(partialResponse -> {
        sink.next(encodedResponse);
    })
    .onCompleteResponse(completeResponse -> {
        sink.complete();
    })
    .start();
});
```

3.3 知识管理方法

`addKnowledgeToVectorStore(String content, String source)` - 向量化存储

java

```java
private void addKnowledgeToVectorStore(String content, String source)
```

**作用**：

- 将单条知识转换为向量并存储
- 支持增量添加知识内容

**处理步骤**：

1. 内容验证和清理
2. 创建TextSegment对象
3. 生成向量嵌入
4. 存储到向量数据库

`testRagRetrieval(String query)` - RAG检索测试

java

```java
public String testRagRetrieval(String query)
```

**作用**：

- 测试RAG检索功能是否正常
- 调试和验证知识库搜索效果

**检索流程**：

1. 使用ContentRetriever检索相关内容
2. 按相似度排序返回结果
3. 格式化输出检索内容

3.4 辅助功能方法

`buildSystemMessageString()` - 系统提示构建

java

```java
private String buildSystemMessageString()
```

**作用**：

- 定义AI助手的角色和行为规范
- 设置回答的专业性和准确性要求

**关键要求**：

- 基于检索信息回答，不编造内容
- 保持专业客服语调
- 提供结构化、可执行的建议
- 维护对话连贯性

`formatFinalResponse()` - 响应格式化

java

```java
private String formatFinalResponse(String aiResponse, String userQuery)
```

**作用**：

- 统一响应格式，添加品牌标识
- 提供额外的客服联系方式
- 增强用户体验

`getSystemStatus()` - 系统状态监控

java

```java
public String getSystemStatus()
```

**作用**：

- 提供系统运行状态的详细信息
- 监控各组件的初始化状态
- 便于运维和故障排查

### MarineBiologyRagController类

#### MarineBiologyRagController概述

MarineBiologyRagController是海洋生物智能客服系统的RESTful API控制器，作为系统的Web服务入口层，负责处理所有来自前端、移动端和第三方系统的HTTP请求。

#### 主要作用

#### 1. **API网关功能**

- **请求接收**：统一接收和处理各种HTTP请求
- **参数验证**：对输入参数进行格式验证和安全检查
- **路由分发**：根据不同的URL路径分发到对应的处理方法
- **响应格式化**：将业务层返回的数据封装成标准化的JSON响应



~~~ java
package com.gec.marine.controller;

import com.gec.marine.entity.Result;
import com.gec.marine.service.MarineBiologyRagService;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.validation.constraints.NotBlank;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * 海洋生物RAG智能客服系统的RESTful API控制器
 *
 * 【控制器概述】
 * 这是系统的Web API入口层，负责：
 * 1. 接收和处理来自前端、移动端、第三方系统的HTTP请求
 * 2. 参数验证和格式化处理
 * 3. 调用业务服务层(FlightRagService)处理具体逻辑
 * 4. 统一封装响应格式并返回JSON数据
 * 5. 异常处理和错误信息标准化
 *
 * 【API设计原则】
 * - RESTful风格：使用标准HTTP方法和状态码
 * - 统一响应格式：所有接口返回结构化的JSON响应
 * - 向后兼容：保留旧版本接口以支持现有客户端
 * - 跨域支持：允许前端跨域访问
 * - 完整错误处理：提供详细的错误信息和日志记录
 *
 * 【支持的客户端】
 * - Web前端(React/Vue等SPA应用)
 * - 移动应用(iOS/Android)
 * - 第三方集成系统
 * - API测试工具(Postman等)
 *
 * @author System
 * @version 1.0
 * @since 2024-01-01
 */
@RestController                                    // 标识为REST控制器，自动进行JSON序列化
@RequestMapping("/marineBiology")                         // 统一路由前缀，所有接口都以/flight开头
@CrossOrigin(origins = "*", maxAge = 3600)        // 跨域配置：允许所有域名访问，缓存预检请求1小时
public class MarineBiologyRagController {

    // 日志记录器，用于记录请求处理过程和错误信息
    private static final Logger logger = LoggerFactory.getLogger(MarineBiologyRagController.class);

    /**
     * 注入MarineBiologyRagService业务服务
     * 通过依赖注入获取RAG服务实例，实现控制器与业务逻辑的解耦
     */
    @Autowired
    private MarineBiologyRagService marineBiologyRagService;

    // 或者，如果您希望始终返回 HTTP 200 状态码，可以这样写：
    @PostMapping("/query")
    public Result<Map<String, Object>> query(
            @RequestBody @NotBlank(message = "查询内容不能为空") String query) {
        logger.info("收到查询请求: {}", query);
        try {
            // 调用RAG服务处理查询，trim()去除首尾空格
            String response = marineBiologyRagService.processQuery(query.trim());

            // 构建查询结果数据
            Map<String, Object> queryData = new HashMap<>();
            queryData.put("timestamp", LocalDateTime.now());   // 处理时间戳
            queryData.put("query", query);                     // 原始查询内容
            queryData.put("response", response);               // AI生成的回答
            queryData.put("message", "查询成功");               // 处理状态描述

            // 返回成功结果
            return Result.ok(queryData);

        } catch (Exception e) {
            // 记录错误日志，包含完整的异常堆栈信息
            logger.error("处理查询请求失败: {}", e.getMessage(), e);

            // 返回失败结果
            String errorMessage = "系统处理异常，请稍后重试: " + e.getMessage();
            return Result.failed(errorMessage);
        }
    }

    // 1. 修改Controller方法，添加正确的编码设置
    @GetMapping(value = "/stream", produces = "text/event-stream;charset=UTF-8")
    public Flux<String> chatStream(@RequestParam String message, HttpServletResponse response) {
        // 设置响应头确保UTF-8编码
        response.setCharacterEncoding("UTF-8");
        response.setContentType("text/event-stream;charset=UTF-8");
        response.setHeader("Cache-Control", "no-cache");
        response.setHeader("Connection", "keep-alive");

        return marineBiologyRagService.processQueryStream(message);
    }


}
~~~

### 配置文件:application.yml

~~~ yaml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/ocean_db?useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai&useSSL=false
    username: root
    password: 1111
    # Druid 数据源配置
    druid:
      initial-size: 5  # 初始化连接数
      min-idle: 5      # 最小空闲连接数
      max-active: 20   # 最大连接数
      max-wait: 60000  # 获取连接时最大等待时间
      validation-query: SELECT 1 FROM DUAL  # 校验连接的SQL
mybatis-plus:
  # 不支持多包, 如有需要可在注解配置 或 提升扫包等级
  # 例如 com.**.**.mapper
  mapperPackage: com.gec.marine.mapper
  # 对应的 XML 文件位置
  mapperLocations: classpath*:mapper/**/*Mapper.xml
  # 实体扫描，多个package用逗号或者分号分隔
  typeAliasesPackage: com.gec.marine.entity
  # 启动时是否检查 MyBatis XML 文件的存在，默认不检查
  checkConfigLocation: false
  configuration:
    # 自动驼峰命名规则（camel case）映射   数据库表的字段user_name---->实体类的userName
    mapUnderscoreToCamelCase: true
    # MyBatis 自动映射策略
    # NONE：不启用 PARTIAL：只对非嵌套 resultMap 自动映射 FULL：对所有 resultMap 自动映射
    autoMappingBehavior: FULL
    # MyBatis 自动映射时未知列或未知属性处理策
    # NONE：不做处理 WARNING：打印相关警告 FAILING：抛出异常和详细信息
    autoMappingUnknownColumnBehavior: NONE
    # 更详细的日志输出 会有性能损耗 org.apache.ibatis.logging.stdout.StdOutImpl
    # 默认日志输出 org.apache.ibatis.logging.slf4j.Slf4jImpl
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
server:
  servlet:
    context-path: /mrsp_server
  port: 8080
# 通义千问配置
qwen:
  api-key: 自己审请的key
  chat-model: qwen-plus
  embedding-model: text-embedding-v1
  temperature: 0.3
  max-tokens: 2000
deepseek:
  api-key: 自己审请的key
  model: deepseek-chat
  base-url: https://api.deepseek.com/v1
  timeout: 60
  max-tokens: 4000
  temperature: 0.3
~~~

### 主类MarineRecognitionApplication

~~~ java
package com.gec.marine;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
@MapperScan("com.gec.marine.mapper")
public class MarineRecognitionApplication {
    public static void main(String[] args) {
        SpringApplication.run(MarineRecognitionApplication.class,args);
    }
}
~~~

# 2. 前端功能实现

## 2.1 marineBiology.js

~~~ js
import http from '@/utils/request.js'

/**
 * 海洋生物智能助手 API 服务
 */
export const marineBiologyApi = {
    /**
     * 发送查询消息
     * @param {string} query 查询内容
     * @returns {Promise}
     */
    query(query) {
        return http.post('/marineBiology/query', query)
    }
}

export default marineBiologyApi
~~~

## 2.2 MarineBiologyAssistant.vue

~~~ vue
<template>
  <div class="app">
    <!-- 海洋气泡背景 -->
    <div
        v-for="bubble in bubbles"
        :key="bubble.id"
        class="bubble"
        :style="bubble.style"
    ></div>

    <div class="chat-container">
      <!-- 聊天头部 -->
      <div class="chat-header">
        <div
            class="status-indicator"
            :class="{ 'status-error': systemStatus !== 'UP' }"
            :title="systemStatus === 'UP' ? '系统运行正常' : '系统异常'"
        ></div>
        <h1>🐠 海洋生物智能助手</h1>
        <p>探索神秘的海洋世界，了解各种海洋生物的奥秘</p>
      </div>

      <!-- 聊天消息区域 -->
      <div class="chat-messages" ref="messagesContainer">
        <!-- 欢迎消息 -->
        <div v-if="messages.length === 0" class="welcome-message">
          <h3>🌊 欢迎来到海洋世界！</h3>
          <p>我是您的海洋生物专家助手，可以为您介绍各种海洋生物的习性、特征、生态环境等知识</p>
        </div>

        <!-- 快速问题 -->
        <div v-if="messages.length === 0" class="quick-questions">
          <div
              v-for="question in quickQuestions"
              :key="question"
              class="quick-question"
              @click="sendQuickQuestion(question)"
          >
            {{ question }}
          </div>
        </div>

        <!-- 消息列表 -->
        <div
            v-for="message in messages"
            :key="message.id"
            class="message"
            :class="message.type"
        >
          <div
              class="message-content"
              :class="{ 'error-message': message.isError }"
              v-html="message.content.replace(/\n/g, '<br>')"
          ></div>
          <div class="message-time">{{ message.time }}</div>
        </div>

        <!-- 输入指示器 -->
        <div v-if="isTyping" class="typing-indicator">
          <span>海洋助手正在思考</span>
          <div class="typing-dots">
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
          </div>
        </div>
      </div>

      <!-- 输入区域 -->
      <div class="chat-input-container">
        <div class="chat-input-wrapper">
          <textarea
              v-model="inputMessage"
              ref="chatInput"
              class="chat-input"
              placeholder="请问我关于海洋生物的问题，如：鲨鱼有多少种类？"
              rows="1"
              :disabled="isLoading"
              @keydown="handleKeydown"
              @input="autoResizeTextarea"
          ></textarea>
          <button
              class="send-button"
              :disabled="isLoading || !inputMessage.trim()"
              @click="sendMessage"
          >
            <div v-if="isLoading" class="loading">⟳</div>
            <span v-else>➤</span>
          </button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, reactive, onMounted, nextTick, watch } from 'vue'
import { marineBiologyApi } from '@/api/marineBiology.js'

// 响应式数据
const messages = ref([])
const inputMessage = ref('')
const isLoading = ref(false)
const isTyping = ref(false)
const systemStatus = ref('UP')
const bubbles = ref([])
const messagesContainer = ref(null)
const chatInput = ref(null)

// 快速问题列表
const quickQuestions = [
  '🐋 鲸鱼是如何呼吸的？',
  '🐬 海豚有多聪明？',
  '🪸 珊瑚礁生态系统',
  '🦑 深海生物有哪些？',
  '🌊 海洋污染的影响'
]

// 消息ID计数器
let messageIdCounter = 0
let bubbleIdCounter = 0

// 生命周期
onMounted(() => {
  createBubbles()
  // 每3秒创建新气泡
  setInterval(createBubbles, 3000)
})

// 监听消息变化，自动滚动到底部
watch(messages, () => {
  nextTick(() => {
    scrollToBottom()
  })
}, { deep: true })

// 检查系统状态
const checkSystemStatus = async () => {
  try {
    const response = await marineBiologyApi.getSystemHealth()
    systemStatus.value = response.status
  } catch (error) {
    console.error('系统状态检查失败:', error)
    systemStatus.value = 'ERROR'
  }
}

// 创建海洋气泡效果
const createBubbles = () => {
  const bubble = {
    id: bubbleIdCounter++,
    style: {
      width: Math.random() * 20 + 10 + 'px',
      height: Math.random() * 20 + 10 + 'px',
      left: Math.random() * 100 + '%',
      animationDuration: (Math.random() * 3 + 4) + 's'
    }
  }

  bubbles.value.push(bubble)

  // 7秒后移除气泡
  setTimeout(() => {
    const index = bubbles.value.findIndex(b => b.id === bubble.id)
    if (index > -1) {
      bubbles.value.splice(index, 1)
    }
  }, 7000)
}

// 自动调整文本框高度
const autoResizeTextarea = () => {
  nextTick(() => {
    if (chatInput.value) {
      chatInput.value.style.height = 'auto'
      chatInput.value.style.height = Math.min(chatInput.value.scrollHeight, 120) + 'px'
    }
  })
}

// 处理键盘事件
const handleKeydown = (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault()
    sendMessage()
  }
}

// 发送消息
const sendMessage = async () => {
  const message = inputMessage.value.trim()
  if (!message || isLoading.value) return

  // 添加用户消息
  addMessage(message, 'user')
  inputMessage.value = ''
  autoResizeTextarea()

  // 设置加载状态
  isLoading.value = true
  isTyping.value = true

  try {
    const response = await marineBiologyApi.query(message)

    isTyping.value = false

    if (response.processResult==='SUCCESS') {
      addMessage(response.queryResultData.response, 'bot')
    } else {
      addMessage(`抱歉，处理您的请求时出现问题：${response.error || response.message}`, 'bot', true)
    }
  } catch (error) {
    console.error('发送消息失败:', error)
    isTyping.value = false
    addMessage('抱歉，网络连接出现问题，请稍后重试。', 'bot', true)
  } finally {
    isLoading.value = false
  }
}

// 快速问题点击
const sendQuickQuestion = (question) => {
  if (isLoading.value) return

  // 移除表情符号，只保留问题文本
  const cleanQuestion = question.replace(/^[🐋🐬🪸🦑🌊]\s*/, '')
  inputMessage.value = cleanQuestion
  sendMessage()
}

// 添加消息
const addMessage = (content, type, isError = false) => {
  const now = new Date()
  const timeStr = now.toLocaleTimeString('zh-CN', {
    hour: '2-digit',
    minute: '2-digit'
  })

  messages.value.push({
    id: messageIdCounter++,
    content,
    type,
    isError,
    time: timeStr
  })
}

// 滚动到底部
const scrollToBottom = () => {
  if (messagesContainer.value) {
    setTimeout(() => {
      messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight
    }, 100)
  }
}
</script>

<style scoped>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

.app {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', sans-serif;
  background: linear-gradient(180deg, #87CEEB 0%, #20B2AA 50%, #191970 100%);
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 20px;
  position: relative;
  overflow: hidden;
}

/* 海洋动画背景 */
.app::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 20"><path d="M0 10 Q25 0 50 10 T100 10 V20 H0 Z" fill="rgba(255,255,255,0.1)"/></svg>') repeat-x;
  animation: wave 10s linear infinite;
  z-index: 1;
}

@keyframes wave {
  0% { transform: translateX(0); }
  100% { transform: translateX(-100px); }
}

.chat-container {
  width: 100%;
  max-width: 800px;
  height: 80vh;
  max-height: 600px;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(15px);
  border-radius: 25px;
  box-shadow: 0 25px 50px rgba(0, 100, 200, 0.2);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  border: 2px solid rgba(32, 178, 170, 0.3);
  position: relative;
  z-index: 10;
}

.chat-header {
  background: linear-gradient(135deg, #20B2AA 0%, #48CAE4 50%, #00B4D8 100%);
  color: white;
  padding: 25px;
  text-align: center;
  position: relative;
  box-shadow: 0 4px 20px rgba(32, 178, 170, 0.3);
}

.chat-header h1 {
  font-size: 28px;
  font-weight: 700;
  margin-bottom: 8px;
  text-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.chat-header p {
  font-size: 15px;
  opacity: 0.95;
  font-weight: 400;
}

.status-indicator {
  position: absolute;
  top: 25px;
  right: 25px;
  width: 14px;
  height: 14px;
  background: #4ade80;
  border-radius: 50%;
  animation: pulse 2s infinite;
  box-shadow: 0 0 10px rgba(74, 222, 128, 0.5);
}

.status-indicator.status-error {
  background: #f87171;
  box-shadow: 0 0 10px rgba(248, 113, 113, 0.5);
}

@keyframes pulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.7; transform: scale(1.1); }
}

.chat-messages {
  flex: 1;
  padding: 25px;
  overflow-y: auto;
  background: linear-gradient(180deg, #f0f9ff 0%, #e0f2fe 100%);
}

.message {
  margin-bottom: 25px;
  display: flex;
  animation: slideUp 0.4s ease-out;
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message.user {
  justify-content: flex-end;
}

.message.bot {
  justify-content: flex-start;
}

.message-content {
  max-width: 75%;
  padding: 18px 24px;
  border-radius: 25px;
  position: relative;
  word-wrap: break-word;
  line-height: 1.6;
  font-size: 15px;
}

.message.user .message-content {
  background: linear-gradient(135deg, #20B2AA 0%, #48CAE4 100%);
  color: white;
  border-bottom-right-radius: 8px;
  box-shadow: 0 4px 15px rgba(32, 178, 170, 0.3);
}

.message.bot .message-content {
  background: white;
  color: #1e293b;
  border: 2px solid #e1f5fe;
  border-bottom-left-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 150, 200, 0.1);
}

.message-time {
  font-size: 12px;
  opacity: 0.7;
  margin-top: 8px;
  text-align: right;
  font-weight: 500;
}

.message.bot .message-time {
  text-align: left;
}

.chat-input-container {
  padding: 25px;
  background: white;
  border-top: 2px solid #e1f5fe;
}

.chat-input-wrapper {
  display: flex;
  gap: 12px;
  align-items: flex-end;
}

.chat-input {
  flex: 1;
  min-height: 50px;
  max-height: 120px;
  padding: 15px 20px;
  border: 2px solid #b3e5fc;
  border-radius: 25px;
  font-size: 15px;
  font-family: inherit;
  resize: none;
  outline: none;
  transition: all 0.3s ease;
  background: #f8fdff;
}

.chat-input:focus {
  border-color: #20B2AA;
  box-shadow: 0 0 0 4px rgba(32, 178, 170, 0.15);
  background: white;
}

.send-button {
  width: 50px;
  height: 50px;
  background: linear-gradient(135deg, #20B2AA 0%, #48CAE4 100%);
  color: white;
  border: none;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  font-size: 20px;
  box-shadow: 0 4px 15px rgba(32, 178, 170, 0.3);
}

.send-button:hover:not(:disabled) {
  transform: scale(1.05) translateY(-2px);
  box-shadow: 0 8px 25px rgba(32, 178, 170, 0.4);
}

.send-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.quick-questions {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 20px;
}

.quick-question {
  background: linear-gradient(135deg, #e1f5fe 0%, #b3e5fc 100%);
  color: #0277bd;
  border: 2px solid #81d4fa;
  padding: 10px 16px;
  border-radius: 20px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.3s ease;
}

.quick-question:hover {
  background: linear-gradient(135deg, #20B2AA 0%, #48CAE4 100%);
  color: white;
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(32, 178, 170, 0.3);
}

.typing-indicator {
  display: flex;
  align-items: center;
  gap: 10px;
  color: #0277bd;
  margin-bottom: 20px;
  font-weight: 500;
}

.typing-dots {
  display: flex;
  gap: 5px;
}

.typing-dot {
  width: 10px;
  height: 10px;
  background: #48CAE4;
  border-radius: 50%;
  animation: typing 1.4s infinite ease-in-out;
}

.typing-dot:nth-child(1) { animation-delay: -0.32s; }
.typing-dot:nth-child(2) { animation-delay: -0.16s; }

@keyframes typing {
  0%, 80%, 100% {
    transform: scale(0.8);
    opacity: 0.5;
  }
  40% {
    transform: scale(1.2);
    opacity: 1;
  }
}

.welcome-message {
  text-align: center;
  color: #0277bd;
  margin: 50px 0;
}

.welcome-message h3 {
  margin-bottom: 15px;
  color: #01579b;
  font-size: 22px;
  font-weight: 600;
}

.welcome-message p {
  font-size: 16px;
  line-height: 1.6;
}

.error-message {
  background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%) !important;
  color: #c62828 !important;
  border-left: 4px solid #f44336 !important;
}

.loading {
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

/* 海洋气泡效果 */
.bubble {
  position: absolute;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  animation: bubble-rise 6s infinite linear;
  z-index: 1;
  pointer-events: none;
}

@keyframes bubble-rise {
  0% {
    bottom: -50px;
    opacity: 0;
  }
  10% {
    opacity: 1;
  }
  90% {
    opacity: 1;
  }
  100% {
    bottom: 100vh;
    opacity: 0;
  }
}

@media (max-width: 768px) {
  .app {
    padding: 10px;
  }

  .chat-container {
    height: 90vh;
    border-radius: 20px;
  }

  .chat-header {
    padding: 20px;
  }

  .chat-header h1 {
    font-size: 24px;
  }

  .message-content {
    max-width: 85%;
  }

  .chat-messages {
    padding: 20px;
  }

  .chat-input-container {
    padding: 20px;
  }
}
</style>
~~~

## 2.3 配置路由

- router/index.js

~~~ js
// router/index.js
import { createRouter, createWebHistory } from 'vue-router'
import { setupAuthGuard } from './guard'

// 路由配置数组
const routes = [
    {
        path: '/login',
        name: 'Login',
        component: () => import('../views/Login.vue'),
        meta: {
            title: '用户登录',
            requiresAuth: false // 登录页面不需要认证
        }
    },
    {
        path: '/',
        redirect: '/dashboard', // 根路径重定向到仪表板
        component: () => import('../components/Layout.vue'),
        meta: { requiresAuth: true },
        children: [
            {
                path: 'dashboard',
                name: 'Dashboard',
                component: () => import('../views/Dashboard.vue'),
                meta: {
                    title: '仪表板',
                    icon: 'House'
                }
            },
            {
                path: 'users',
                name: 'Users',
                component: () => import('../views/Users.vue'),
                meta: {
                    title: '用户管理',
                    icon: 'User'
                }
            },
            {
                path: 'roles', // 新增角色管理路由
                name: 'Roles',
                component: () => import('../views/RoleList.vue'),
                meta: {
                    title: '角色管理',
                    icon: 'UserFilled'
                }
            },
            {
                path: 'profile', // 新增个人中心路由
                name: 'Profile',
                component: () => import('../views/Profile.vue'),
                meta: {
                    title: '个人中心',
                    icon: 'User'
                }
            },
            {
                path: 'settings',
                name: 'Settings',
                component: () => import('../views/Settings.vue'),
                meta: {
                    title: '系统设置',
                    icon: 'Setting'
                }
            },
            {
                path: 'MarineBiology',
                name: 'MarineBiology',
                component: () => import('../views/MarineBiologyAssistant.vue'),
                meta: {
                    title: '海洋生物AI助手',
                    icon: 'Setting'
                }
            }
        ]
    }
]

const router = createRouter({
    history: createWebHistory(),
    routes
})

// 设置认证守卫
setupAuthGuard(router)

// 设置页面标题
router.afterEach((to) => {
    document.title = to.meta.title ? `${to.meta.title} - 系统名称` : '系统名称'
})

export default router
~~~

## 2.4 配置菜单

~~~ vue
<template>
  <div class="layout-container">
    <!-- 侧边栏 -->
    <aside class="sidebar" :class="{ collapsed: isCollapsed }">
      <div class="logo">
        <span v-if="!isCollapsed">管理系统</span>
        <span v-else>MS</span>
      </div>

      <!-- 导航菜单 -->
      <el-menu
          :default-active="activeMenu"
          class="sidebar-menu"
          :collapse="isCollapsed"
          @select="handleMenuSelect"
      >
        <el-menu-item
            v-for="item in menuItems"
            :key="item.path"
            :index="item.path"
        >
          <el-icon><component :is="item.icon" /></el-icon>
          <template #title>{{ item.title }}</template>
        </el-menu-item>
      </el-menu>
    </aside>

    <!-- 主内容区域 -->
    <div class="main-container">
      <!-- 顶部导航栏 -->
      <header class="header">
        <div class="header-left">
          <!-- 菜单折叠按钮 -->
          <el-button
              :icon="isCollapsed ? Expand : Fold"
              @click="toggleSidebar"
              circle
          />
        </div>

        <div class="header-right">
          <el-dropdown @command="handleCommand" v-if="authStore.isAuthenticated">
            <span class="user-info">
            <el-avatar :size="32" :src="userAvatar">
              {{ authStore.userInfo.username?.charAt(0).toUpperCase() }}
            </el-avatar>
            <span class="username">{{ authStore.userInfo.username }}</span>
            <el-icon><ArrowDown /></el-icon>
          </span>
            <template #dropdown>
              <el-dropdown-menu>
                <el-dropdown-item command="profile">
                  <el-icon><User /></el-icon>
                  个人中心
                </el-dropdown-item>
                <el-dropdown-item command="settings">
                  <el-icon><Setting /></el-icon>
                  设置
                </el-dropdown-item>
                <el-dropdown-item divided command="logout">
                  <el-icon><SwitchButton /></el-icon>
                  退出登录
                </el-dropdown-item>
              </el-dropdown-menu>
            </template>
          </el-dropdown>
          <div v-else class="login-btn">
            <el-button type="primary" @click="goToLogin">登录</el-button>
          </div>
        </div>
      </header>

      <!-- 标签页栏 -->
      <div class="tabs-container">
        <el-tabs
            v-model="tabsStore.activeTab"
            type="card"
            closable
            @tab-click="handleTabClick"
            @tab-remove="handleTabRemove"
        >
          <el-tab-pane
              v-for="tab in tabsStore.tabList"
              :key="tab.path"
              :label="tab.title"
              :name="tab.path"
              :closable="tab.closable"
          />
        </el-tabs>

        <!-- 标签页操作按钮 -->
        <div class="tabs-actions">
          <el-dropdown @command="handleTabsCommand">
            <el-button size="small" type="primary" link>
              操作 <el-icon><ArrowDown /></el-icon>
            </el-button>
            <template #dropdown>
              <el-dropdown-menu>
                <el-dropdown-item command="closeOthers">关闭其他</el-dropdown-item>
                <el-dropdown-item command="closeAll">关闭所有</el-dropdown-item>
              </el-dropdown-menu>
            </template>
          </el-dropdown>
        </div>
      </div>

      <!-- 页面内容区域 -->
      <main class="content">
        <router-view />
      </main>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useAuthStore } from '@/stores/auth'
import { useTabsStore } from '../stores/tabs'
import { ElMessageBox, ElMessage } from 'element-plus'
import { Fold, Expand, ArrowDown } from '@element-plus/icons-vue'

// 获取必要的实例和状态
const route = useRoute()
const router = useRouter()
const tabsStore = useTabsStore()
const authStore = useAuthStore()

// 响应式数据
const isCollapsed = ref(false) // 侧边栏折叠状态

// 菜单项配置
const menuItems = [
  { path: '/dashboard', title: '仪表板', icon: 'House' },
  { path: '/users', title: '用户管理', icon: 'User' },
  { path: '/roles', title: '角色管理', icon: 'User' },
  { path: '/settings', title: '系统设置', icon: 'Setting' },
  { path: '/MarineBiology', title: '海洋生物AI助手', icon: 'Setting' }
]

// 计算当前激活的菜单项
const activeMenu = computed(() => route.path)

// 监听路由变化，自动添加标签页
watch(route, (newRoute) => {
  if (newRoute.path !== '/login') {
    tabsStore.addTab({
      path: newRoute.path,
      name: newRoute.name,
      title: newRoute.meta?.title || newRoute.name
    })
  }
}, { immediate: true })

// 切换侧边栏折叠状态方法
// 作用：控制侧边栏的展开和收起，节省屏幕空间
const toggleSidebar = () => {
  isCollapsed.value = !isCollapsed.value
}

// 菜单选择处理方法
// 参数：path - 选中的菜单路径
// 作用：处理菜单点击事件，实现页面跳转和标签页管理
const handleMenuSelect = (path) => {
  router.push(path)
}

// 标签页点击处理方法
// 参数：tab - 点击的标签页对象
// 作用：处理标签页切换，同步路由跳转
const handleTabClick = (tab) => {
  const targetPath = typeof tab === 'string' ? tab : tab.props.name
  if (route.path !== targetPath) {
    router.push(targetPath)
  }
}

// 标签页移除处理方法
// 参数：targetPath - 要移除的标签页路径
// 作用：处理标签页关闭，必要时切换到其他标签页
const handleTabRemove = (targetPath) => {
  const newActivePath = tabsStore.removeTab(targetPath)
  if (newActivePath && route.path === targetPath) {
    router.push(newActivePath)
  }
}

// 标签页操作命令处理方法
// 参数：command - 操作命令（closeOthers/closeAll）
// 作用：处理批量标签页操作
const handleTabsCommand = (command) => {
  switch (command) {
    case 'closeOthers':
      tabsStore.closeOtherTabs(route.path)
      break
    case 'closeAll':
      tabsStore.closeAllTabs()
      if (tabsStore.tabList.length > 0) {
        router.push(tabsStore.tabList[0].path)
      }
      break
  }
}

// 用户操作命令处理方法
// 参数：command - 用户操作命令
// 作用：处理用户相关操作，如个人中心、退出登录
// 处理下拉菜单命令
const handleCommand = async (command) => {
  switch (command) {
    case 'profile':
      router.push('/profile')
      break
    case 'settings':
      router.push('/settings')
      break
    case 'logout':
      handleLogout()
      break
  }
}


// 处理登出
const handleLogout = async () => {
  try {
    await ElMessageBox.confirm(
        '确定要退出登录吗？',
        '提示',
        {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }
    )

    await authStore.logout()
    ElMessage.success('已退出登录')
    router.push('/login')
  } catch (error) {
    if (error !== 'cancel') {
      console.error('登出失败:', error)
    }
  }
}

</script>

<style scoped>
.layout-container {
  display: flex;
  height: 100vh;
}

.sidebar {
  width: 250px;
  background-color: #304156;
  transition: width 0.3s;
  overflow: hidden;
}

.sidebar.collapsed {
  width: 64px;
}

.logo {
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 18px;
  font-weight: bold;
  background-color: #409eff;
}

.sidebar-menu {
  border: none;
  background-color: #304156;
}

.main-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.header {
  height: 60px;
  background: white;
  box-shadow: 0 1px 4px rgba(0,21,41,.08);
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 20px;
}

.header-left {
  display: flex;
  align-items: center;
}

.header-right {
  display: flex;
  align-items: center;
}

.user-info {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  padding: 8px;
  border-radius: 4px;
  transition: background-color 0.3s;
}

.user-info:hover {
  background-color: #f5f5f5;
}

.username {
  margin-left: 8px;
  color: #333;
}

.tabs-container {
  display: flex;
  align-items: center;
  background: white;
  border-bottom: 1px solid #e8e8e8;
  padding: 0 20px;
}

.tabs-container :deep(.el-tabs) {
  flex: 1;
}

.tabs-container :deep(.el-tabs__header) {
  margin: 0;
}

.tabs-actions {
  margin-left: 20px;
}

.content {
  flex: 1;
  padding: 20px;
  background-color: #f0f2f5;
  overflow-y: auto;
}
</style>
~~~



