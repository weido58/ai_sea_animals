# Vue3 + Vite 登录页与主框架实现

## 1. 项目主界面

本教案将指导您使用Vite框架配合Vue3，实现一个完整的管理系统，包含登录界面、左侧导航菜单、右侧标签页和顶部导航栏。

![image-20250608165358793](assets/image-20250608165358793.png)

## 2：项目安装依赖库

### 1.2 安装必要依赖



bash

```bash
npm install vue-router@4 pinia element-plus @element-plus/icons-vue
```

## 3：项目结构设计



```
src/
├── components/          # 公共组件
├── views/              # 页面视图
├── router/             # 路由配置
├── stores/             # Pinia状态管理
├── utils/              # 工具函数
└── assets/             # 静态资源
```

## 4：状态管理实现

### Pinia 概述

Pinia 是 Vue.js 的官方状态管理库，被设计为 Vuex 的继任者。它提供了更简洁、类型安全且易于使用的状态管理解决方案。

1. 什么是 Pinia

Pinia 是一个轻量级的状态管理库，专门为 Vue 3 设计（也支持 Vue 2）。它的名字来源于西班牙语中的"菠萝"（piña），象征着由多个独立部分组成的整体。

### 4.1 用户状态管理 (stores/user.js)



javascript

```javascript
import { defineStore } from 'pinia'

export const useUserStore = defineStore('user', {
  // 状态定义
  state: () => ({
    // 用户信息对象，包含用户名、角色等基本信息
    userInfo: null,
    // 登录状态标识，用于判断用户是否已登录
    isLoggedIn: false,
    // 用户权限列表，用于控制菜单显示和页面访问
    permissions: []
  }),

  // 计算属性
  getters: {
    // 获取用户名的计算属性
    // 作用：提供统一的用户名获取方式，避免重复的null检查
    username: (state) => state.userInfo?.username || '未登录',
    
    // 检查用户是否具有特定权限
    // 作用：用于组件中的权限判断，控制按钮或功能的显示
    hasPermission: (state) => (permission) => {
      return state.permissions.includes(permission)
    }
  },

  // 动作方法
  actions: {
    // 用户登录方法
    // 参数：loginForm - 包含用户名和密码的登录表单对象
    // 作用：处理用户登录逻辑，验证用户凭据并更新状态
    async login(loginForm) {
      try {
        // 模拟API请求延迟
        await new Promise(resolve => setTimeout(resolve, 1000))
        
        // 简单的登录验证逻辑（实际项目中应调用后端API）
        if (loginForm.username === 'admin' && loginForm.password === '123456') {
          // 设置用户信息
          this.userInfo = {
            id: 1,
            username: loginForm.username,
            role: 'admin',
            avatar: '/src/assets/avatar.png'
          }
          // 更新登录状态
          this.isLoggedIn = true
          // 设置用户权限
          this.permissions = ['user:read', 'user:write', 'system:config']
          
          // 将登录状态保存到本地存储
          localStorage.setItem('userInfo', JSON.stringify(this.userInfo))
          localStorage.setItem('isLoggedIn', 'true')
          
          return { success: true, message: '登录成功' }
        } else {
          return { success: false, message: '用户名或密码错误' }
        }
      } catch (error) {
        return { success: false, message: '登录过程中发生错误' }
      }
    },

    // 用户登出方法
    // 作用：清除用户登录状态和相关信息，返回登录页面
    logout() {
      // 重置状态
      this.userInfo = null
      this.isLoggedIn = false
      this.permissions = []
      
      // 清除本地存储
      localStorage.removeItem('userInfo')
      localStorage.removeItem('isLoggedIn')
    },

    // 从本地存储恢复登录状态
    // 作用：页面刷新后恢复用户登录状态，提升用户体验
    restoreLoginState() {
      const savedUserInfo = localStorage.getItem('userInfo')
      const savedLoginState = localStorage.getItem('isLoggedIn')
      
      if (savedUserInfo && savedLoginState === 'true') {
        this.userInfo = JSON.parse(savedUserInfo)
        this.isLoggedIn = true
        this.permissions = ['user:read', 'user:write', 'system:config']
      }
    }
  }
})
```

### 4.2 标签页状态管理 (stores/tabs.js)



javascript

```javascript
import { defineStore } from 'pinia'

export const useTabsStore = defineStore('tabs', {
  state: () => ({
    // 标签页列表，存储所有打开的标签页信息
    tabList: [],
    // 当前激活的标签页路径
    activeTab: ''
  }),

  actions: {
    // 添加新标签页方法
    // 参数：tab - 标签页对象，包含path、name、title等属性
    // 作用：在标签栏中添加新的标签页，避免重复添加
    addTab(tab) {
      // 检查标签页是否已存在
      const exists = this.tabList.some(item => item.path === tab.path)
      if (!exists) {
        this.tabList.push({
          path: tab.path,
          name: tab.name,
          title: tab.title || tab.name,
          closable: tab.path !== '/dashboard' // 首页标签不可关闭
        })
      }
      // 设置为当前激活标签
      this.activeTab = tab.path
    },

    // 移除标签页方法
    // 参数：targetPath - 要移除的标签页路径
    // 作用：从标签栏中移除指定标签页，并处理激活状态切换
    removeTab(targetPath) {
      const index = this.tabList.findIndex(tab => tab.path === targetPath)
      if (index > -1) {
        this.tabList.splice(index, 1)
        
        // 如果移除的是当前激活标签，需要切换到其他标签
        if (this.activeTab === targetPath && this.tabList.length > 0) {
          // 优先激活前一个标签，如果没有则激活后一个
          const newIndex = index > 0 ? index - 1 : 0
          this.activeTab = this.tabList[newIndex].path
          return this.tabList[newIndex].path
        }
      }
      return null
    },

    // 设置激活标签页方法
    // 参数：path - 标签页路径
    // 作用：切换当前激活的标签页
    setActiveTab(path) {
      this.activeTab = path
    },

    // 关闭其他标签页方法
    // 参数：keepPath - 要保留的标签页路径
    // 作用：关闭除指定标签外的所有其他标签页
    closeOtherTabs(keepPath) {
      this.tabList = this.tabList.filter(tab => 
        tab.path === keepPath || !tab.closable
      )
      this.activeTab = keepPath
    },

    // 关闭所有标签页方法
    // 作用：关闭所有可关闭的标签页，通常保留首页
    closeAllTabs() {
      this.tabList = this.tabList.filter(tab => !tab.closable)
      if (this.tabList.length > 0) {
        this.activeTab = this.tabList[0].path
      }
    }
  }
})
```

## 5：路由配置

### 5.1 路由设置 (router/index.js)



javascript

```javascript
import { createRouter, createWebHistory } from 'vue-router'
import { useUserStore } from '../stores/user'

// 路由配置数组
const routes = [
  {
    path: '/login',
    name: 'Login',
    component: () => import('../views/Login.vue'),
    meta: { 
      title: '用户登录',
      requiresAuth: false // 登录页面不需要认证
    }
  },
  {
    path: '/',
    redirect: '/dashboard', // 根路径重定向到仪表板
    component: () => import('../components/Layout.vue'),
    meta: { requiresAuth: true },
    children: [
      {
        path: 'dashboard',
        name: 'Dashboard',
        component: () => import('../views/Dashboard.vue'),
        meta: { 
          title: '仪表板',
          icon: 'House'
        }
      },
      {
        path: 'users',
        name: 'Users',
        component: () => import('../views/Users.vue'),
        meta: { 
          title: '用户管理',
          icon: 'User'
        }
      },
      {
        path: 'settings',
        name: 'Settings',
        component: () => import('../views/Settings.vue'),
        meta: { 
          title: '系统设置',
          icon: 'Setting'
        }
      }
    ]
  }
]

// 创建路由实例
const router = createRouter({
  history: createWebHistory(),
  routes
})

// 全局前置守卫
// 作用：在每次路由跳转前进行权限验证和登录状态检查
router.beforeEach((to, from, next) => {
  const userStore = useUserStore()
  
  // 恢复登录状态（防止页面刷新后状态丢失）
  userStore.restoreLoginState()
  
  // 检查目标路由是否需要认证
  if (to.meta.requiresAuth) {
    if (userStore.isLoggedIn) {
      next() // 已登录，允许访问
    } else {
      next('/login') // 未登录，重定向到登录页
    }
  } else {
    // 如果用户已登录且访问登录页，重定向到首页
    if (to.path === '/login' && userStore.isLoggedIn) {
      next('/dashboard')
    } else {
      next() // 不需要认证的页面，直接访问
    }
  }
})

export default router
```



这是一个Vue 3项目中使用Vue Router 4的完整路由配置文件。让我详细解释每个部分的作用：

1. 导入依赖



javascript

```javascript
import { createRouter, createWebHistory } from 'vue-router'
import { useUserStore } from '../stores/user'
```

- `createRouter`: 创建路由实例的函数
- `createWebHistory`: 使用HTML5 History API的路由模式（URL不带#号）
- `useUserStore`: 导入用户状态管理store，用于处理登录状态

2. 路由配置数组

登录路由



javascript

```javascript
{
  path: '/login',
  name: 'Login',
  component: () => import('../views/Login.vue'),
  meta: { 
    title: '用户登录',
    requiresAuth: false // 不需要登录验证
  }
}
```

主布局路由（嵌套路由）



javascript

```javascript
{
  path: '/',
  redirect: '/dashboard', // 访问根路径时自动跳转到仪表板
  component: () => import('../components/Layout.vue'), // 主布局组件
  meta: { requiresAuth: true }, // 需要登录验证
  children: [
    // 子路由配置...
  ]
}
```

**子路由说明：**

- `dashboard`: 仪表板页面
- `users`: 用户管理页面
- `settings`: 系统设置页面

每个子路由都包含：

- `title`: 页面标题
- `icon`: 菜单图标名称
- `requiresAuth`: 继承父路由，都需要登录验证

3. 路由实例创建



javascript

```javascript
const router = createRouter({
  history: createWebHistory(), // 使用History模式
  routes // 路由配置
})
```

4. 全局前置守卫（核心权限控制）



javascript

```javascript
router.beforeEach((to, from, next) => {
  // 守卫逻辑...
})
```

守卫执行流程：

1. 获取用户状态

   

   javascript

   ```javascript
   const userStore = useUserStore()
   userStore.restoreLoginState() // 恢复登录状态（处理页面刷新）
   ```

2. 权限验证逻辑

   

   javascript

   ```javascript
   if (to.meta.requiresAuth) {
     // 需要认证的页面
     if (userStore.isLoggedIn) {
       next() // 已登录 → 允许访问
     } else {
       next('/login') // 未登录 → 跳转登录页
     }
   } else {
     // 不需要认证的页面
     if (to.path === '/login' && userStore.isLoggedIn) {
       next('/dashboard') // 已登录用户访问登录页 → 跳转仪表板
     } else {
       next() // 正常访问
     }
   }
   ```

5. 路由保护机制

这个配置实现了完整的路由保护：

- **防止未登录访问**：未登录用户访问需要认证的页面时，自动跳转到登录页
- **防止重复登录**：已登录用户访问登录页时，自动跳转到仪表板
- **状态恢复**：页面刷新后自动恢复登录状态
- **嵌套路由保护**：父路由的认证要求会影响所有子路由

## 6：登录界面实现

### 6.1 登录组件 (views/Login.vue)



vue

```vue
<template>
  <div class="login-container">
    <!-- 登录卡片容器 -->
    <div class="login-card">
      <!-- 登录标题 -->
      <h2 class="login-title">系统登录</h2>
      
      <!-- 登录表单 -->
      <el-form
        ref="loginFormRef"
        :model="loginForm"
        :rules="loginRules"
        class="login-form"
        @submit.prevent="handleLogin"
      >
        <!-- 用户名输入框 -->
        <el-form-item prop="username">
          <el-input
            v-model="loginForm.username"
            placeholder="请输入用户名"
            size="large"
            prefix-icon="User"
            clearable
          />
        </el-form-item>
        
        <!-- 密码输入框 -->
        <el-form-item prop="password">
          <el-input
            v-model="loginForm.password"
            type="password"
            placeholder="请输入密码"
            size="large"
            prefix-icon="Lock"
            show-password
            @keyup.enter="handleLogin"
          />
        </el-form-item>
        
        <!-- 登录按钮 -->
        <el-form-item>
          <el-button
            type="primary"
            size="large"
            :loading="loading"
            @click="handleLogin"
            class="login-button"
          >
            {{ loading ? '登录中...' : '登录' }}
          </el-button>
        </el-form-item>
      </el-form>
      
      <!-- 登录提示信息 -->
      <div class="login-tips">
        <p>默认账号：admin</p>
        <p>默认密码：123456</p>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, reactive } from 'vue'
import { useRouter } from 'vue-router'
import { useUserStore } from '../stores/user'
import { ElMessage } from 'element-plus'

// 获取路由实例和用户状态管理
const router = useRouter()
const userStore = useUserStore()

// 响应式数据定义
const loading = ref(false) // 登录加载状态
const loginFormRef = ref() // 表单引用

// 登录表单数据
const loginForm = reactive({
  username: '',
  password: ''
})

// 表单验证规则
const loginRules = {
  username: [
    { required: true, message: '请输入用户名', trigger: 'blur' },
    { min: 2, max: 20, message: '用户名长度应在2-20个字符', trigger: 'blur' }
  ],
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' },
    { min: 6, max: 20, message: '密码长度应在6-20个字符', trigger: 'blur' }
  ]
}

// 登录处理方法
// 作用：处理用户登录逻辑，包括表单验证、登录请求和页面跳转
const handleLogin = async () => {
  try {
    // 表单验证
    await loginFormRef.value.validate()
    
    loading.value = true
    
    // 调用登录接口
    const result = await userStore.login(loginForm)
    
    if (result.success) {
      ElMessage.success(result.message)
      // 登录成功后跳转到首页
      await router.push('/dashboard')
    } else {
      ElMessage.error(result.message)
    }
  } catch (error) {
    console.error('登录表单验证失败:', error)
  } finally {
    loading.value = false
  }
}
</script>

<style scoped>
.login-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

.login-card {
  width: 400px;
  padding: 40px;
  background: white;
  border-radius: 10px;
  box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
}

.login-title {
  text-align: center;
  margin-bottom: 30px;
  color: #333;
  font-size: 24px;
  font-weight: 500;
}

.login-form {
  margin-bottom: 20px;
}

.login-button {
  width: 100%;
  height: 45px;
  font-size: 16px;
}

.login-tips {
  text-align: center;
  color: #666;
  font-size: 14px;
  line-height: 1.5;
}

.login-tips p {
  margin: 5px 0;
}
</style>
```

## 7：主框架布局实现

### 7.1 主布局组件 (components/Layout.vue)



vue

```vue
<template>
  <div class="layout-container">
    <!-- 侧边栏 -->
    <aside class="sidebar" :class="{ collapsed: isCollapsed }">
      <div class="logo">
        <span v-if="!isCollapsed">管理系统</span>
        <span v-else>MS</span>
      </div>
      
      <!-- 导航菜单 -->
      <el-menu
        :default-active="activeMenu"
        class="sidebar-menu"
        :collapse="isCollapsed"
        @select="handleMenuSelect"
      >
        <el-menu-item
          v-for="item in menuItems"
          :key="item.path"
          :index="item.path"
        >
          <el-icon><component :is="item.icon" /></el-icon>
          <template #title>{{ item.title }}</template>
        </el-menu-item>
      </el-menu>
    </aside>
    
    <!-- 主内容区域 -->
    <div class="main-container">
      <!-- 顶部导航栏 -->
      <header class="header">
        <div class="header-left">
          <!-- 菜单折叠按钮 -->
          <el-button
            :icon="isCollapsed ? Expand : Fold"
            @click="toggleSidebar"
            circle
          />
        </div>
        
        <div class="header-right">
          <!-- 用户信息下拉菜单 -->
          <el-dropdown @command="handleUserCommand">
            <div class="user-info">
              <el-avatar :size="32" :src="userStore.userInfo?.avatar" />
              <span class="username">{{ userStore.username }}</span>
              <el-icon><ArrowDown /></el-icon>
            </div>
            <template #dropdown>
              <el-dropdown-menu>
                <el-dropdown-item command="profile">个人中心</el-dropdown-item>
                <el-dropdown-item command="logout" divided>退出登录</el-dropdown-item>
              </el-dropdown-menu>
            </template>
          </el-dropdown>
        </div>
      </header>
      
      <!-- 标签页栏 -->
      <div class="tabs-container">
        <el-tabs
          v-model="tabsStore.activeTab"
          type="card"
          closable
          @tab-click="handleTabClick"
          @tab-remove="handleTabRemove"
        >
          <el-tab-pane
            v-for="tab in tabsStore.tabList"
            :key="tab.path"
            :label="tab.title"
            :name="tab.path"
            :closable="tab.closable"
          />
        </el-tabs>
        
        <!-- 标签页操作按钮 -->
        <div class="tabs-actions">
          <el-dropdown @command="handleTabsCommand">
            <el-button size="small" type="primary" link>
              操作 <el-icon><ArrowDown /></el-icon>
            </el-button>
            <template #dropdown>
              <el-dropdown-menu>
                <el-dropdown-item command="closeOthers">关闭其他</el-dropdown-item>
                <el-dropdown-item command="closeAll">关闭所有</el-dropdown-item>
              </el-dropdown-menu>
            </template>
          </el-dropdown>
        </div>
      </div>
      
      <!-- 页面内容区域 -->
      <main class="content">
        <router-view />
      </main>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useUserStore } from '../stores/user'
import { useTabsStore } from '../stores/tabs'
import { ElMessageBox, ElMessage } from 'element-plus'
import { Fold, Expand, ArrowDown } from '@element-plus/icons-vue'

// 获取必要的实例和状态
const route = useRoute()
const router = useRouter()
const userStore = useUserStore()
const tabsStore = useTabsStore()

// 响应式数据
const isCollapsed = ref(false) // 侧边栏折叠状态

// 菜单项配置
const menuItems = [
  { path: '/dashboard', title: '仪表板', icon: 'House' },
  { path: '/users', title: '用户管理', icon: 'User' },
  { path: '/settings', title: '系统设置', icon: 'Setting' }
]

// 计算当前激活的菜单项
const activeMenu = computed(() => route.path)

// 监听路由变化，自动添加标签页
watch(route, (newRoute) => {
  if (newRoute.path !== '/login') {
    tabsStore.addTab({
      path: newRoute.path,
      name: newRoute.name,
      title: newRoute.meta?.title || newRoute.name
    })
  }
}, { immediate: true })

// 切换侧边栏折叠状态方法
// 作用：控制侧边栏的展开和收起，节省屏幕空间
const toggleSidebar = () => {
  isCollapsed.value = !isCollapsed.value
}

// 菜单选择处理方法
// 参数：path - 选中的菜单路径
// 作用：处理菜单点击事件，实现页面跳转和标签页管理
const handleMenuSelect = (path) => {
  router.push(path)
}

// 标签页点击处理方法
// 参数：tab - 点击的标签页对象
// 作用：处理标签页切换，同步路由跳转
const handleTabClick = (tab) => {
  const targetPath = typeof tab === 'string' ? tab : tab.props.name
  if (route.path !== targetPath) {
    router.push(targetPath)
  }
}

// 标签页移除处理方法
// 参数：targetPath - 要移除的标签页路径
// 作用：处理标签页关闭，必要时切换到其他标签页
const handleTabRemove = (targetPath) => {
  const newActivePath = tabsStore.removeTab(targetPath)
  if (newActivePath && route.path === targetPath) {
    router.push(newActivePath)
  }
}

// 标签页操作命令处理方法
// 参数：command - 操作命令（closeOthers/closeAll）
// 作用：处理批量标签页操作
const handleTabsCommand = (command) => {
  switch (command) {
    case 'closeOthers':
      tabsStore.closeOtherTabs(route.path)
      break
    case 'closeAll':
      tabsStore.closeAllTabs()
      if (tabsStore.tabList.length > 0) {
        router.push(tabsStore.tabList[0].path)
      }
      break
  }
}

// 用户操作命令处理方法
// 参数：command - 用户操作命令
// 作用：处理用户相关操作，如个人中心、退出登录
const handleUserCommand = async (command) => {
  switch (command) {
    case 'profile':
      ElMessage.info('个人中心功能开发中...')
      break
    case 'logout':
      try {
        await ElMessageBox.confirm('确定要退出登录吗？', '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        })
        
        userStore.logout()
        await router.push('/login')
        ElMessage.success('已退出登录')
      } catch (error) {
        // 用户取消操作
      }
      break
  }
}
</script>

<style scoped>
.layout-container {
  display: flex;
  height: 100vh;
}

.sidebar {
  width: 250px;
  background-color: #304156;
  transition: width 0.3s;
  overflow: hidden;
}

.sidebar.collapsed {
  width: 64px;
}

.logo {
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 18px;
  font-weight: bold;
  background-color: #409eff;
}

.sidebar-menu {
  border: none;
  background-color: #304156;
}

.main-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.header {
  height: 60px;
  background: white;
  box-shadow: 0 1px 4px rgba(0,21,41,.08);
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 20px;
}

.header-left {
  display: flex;
  align-items: center;
}

.header-right {
  display: flex;
  align-items: center;
}

.user-info {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  padding: 8px;
  border-radius: 4px;
  transition: background-color 0.3s;
}

.user-info:hover {
  background-color: #f5f5f5;
}

.username {
  margin-left: 8px;
  color: #333;
}

.tabs-container {
  display: flex;
  align-items: center;
  background: white;
  border-bottom: 1px solid #e8e8e8;
  padding: 0 20px;
}

.tabs-container :deep(.el-tabs) {
  flex: 1;
}

.tabs-container :deep(.el-tabs__header) {
  margin: 0;
}

.tabs-actions {
  margin-left: 20px;
}

.content {
  flex: 1;
  padding: 20px;
  background-color: #f0f2f5;
  overflow-y: auto;
}
</style>
```

## 8：页面组件实现

### 8.1 仪表板组件 (views/Dashboard.vue)



vue

```vue
<template>
  <div class="dashboard">
    <h1>仪表板</h1>
    <div class="dashboard-content">
      <!-- 统计卡片 -->
      <div class="stats-grid">
        <div class="stat-card" v-for="stat in stats" :key="stat.title">
          <div class="stat-icon" :style="{ backgroundColor: stat.color }">
            <el-icon><component :is="stat.icon" /></el-icon>
          </div>
          <div class="stat-info">
            <h3>{{ stat.value }}</h3>
            <p>{{ stat.title }}</p>
          </div>
        </div>
      </div>
      
      <!-- 欢迎信息 -->
      <el-card class="welcome-card">
        <h2>欢迎回来，{{ userStore.username }}！</h2>
        <p>今天是 {{ currentDate }}，祝您工作愉快！</p>
      </el-card>
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'
import { useUserStore } from '../stores/user'

const userStore = useUserStore()

// 统计数据
const stats = ref([
  { title: '总用户数', value: '1,234', icon: 'User', color: '#409eff' },
  { title: '今日访问', value: '856', icon: 'View', color: '#67c23a' },
  { title: '系统消息', value: '12', icon: 'Message', color: '#e6a23c' },
  { title: '待处理', value: '5', icon: 'Warning', color: '#f56c6c' }
])

// 当前日期
const currentDate = computed(() => {
  return new Date().toLocaleDateString('zh-CN', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    weekday: 'long'
  })
})
</script>

<style scoped>
.dashboard {
  padding: 20px;
}

.dashboard h1 {
  margin-bottom: 20px;
  color: #333;
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px;
  margin-bottom: 20px;
}

.stat-card {
  background: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  display: flex;
  align-items: center;
}

.stat-icon {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  margin-right: 15px;
}

.stat-info h3 {
  margin: 0;
  font-size: 24px;
  color: #333;
}

.stat-info p {
  margin: 5px 0 0 0;
  color: #666;
}

.welcome-card {
  margin-top: 20px;
}

.welcome-card h2 {
  margin: 0 0 10px 0;
  color: #333;
}

.welcome-card p {
  margin: 0;
  color: #666;
}
</style>
```

## 9：应用入口配置

### 9.1 主应用文件 (main.js)



javascript

```javascript
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'
import * as ElementPlusIconsVue from '@element-plus/icons-vue'
import App from './App.vue'
import router from './router'

// 创建Vue应用实例
const app = createApp(App)

// 创建Pinia状态管理实例
const pinia = createPinia()

// 注册Element Plus图标组件
// 作用：全局注册所有Element Plus图标，可在任何组件中使用
for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
  app.component(key, component)
}

// 应用插件和配置
app.use(pinia)           // 使用Pinia状态管理
app.use(router)          // 使用Vue Router路由
app.use(ElementPlus)     // 使用Element Plus UI组件库

// 挂载应用到DOM
app.mount('#app')
```

### 9.2 根组件 (App.vue)



vue

```vue
<template>
  <div id="app">
    <!-- 路由视图容器 -->
    <router-view />
  </div>
</template>

<script setup>
// 根组件无需额外逻辑，主要作为应用容器
</script>

<style>
/* 全局样式重置 */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  height: 100%;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

#app {
  height: 100%;
}

/* 自定义滚动条样式 */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 3px;
}

::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: #a8a8a8;
}
</style>
```

## 10：页面组件补充实现

### 10.1 用户管理页面 (views/Users.vue)



vue

```vue
<template>
  <div class="users-page">
    <div class="page-header">
      <h1>用户管理</h1>
      <el-button type="primary" @click="handleAddUser">
        <el-icon><Plus /></el-icon>
        新增用户
      </el-button>
    </div>
    
    <!-- 搜索筛选区域 -->
    <el-card class="search-card">
      <el-form :inline="true" :model="searchForm" class="search-form">
        <el-form-item label="用户名">
          <el-input 
            v-model="searchForm.username" 
            placeholder="请输入用户名"
            clearable
          />
        </el-form-item>
        <el-form-item label="状态">
          <el-select v-model="searchForm.status" placeholder="请选择状态" clearable>
            <el-option label="启用" value="1" />
            <el-option label="禁用" value="0" />
          </el-select>
        </el-form-item>
        <el-form-item>
          <el-button type="primary" @click="handleSearch">搜索</el-button>
          <el-button @click="handleReset">重置</el-button>
        </el-form-item>
      </el-form>
    </el-card>
    
    <!-- 用户列表表格 -->
    <el-card class="table-card">
      <el-table :data="userList" v-loading="loading" stripe>
        <el-table-column prop="id" label="ID" width="80" />
        <el-table-column prop="username" label="用户名" />
        <el-table-column prop="email" label="邮箱" />
        <el-table-column prop="role" label="角色" />
        <el-table-column prop="status" label="状态" width="100">
          <template #default="scope">
            <el-tag :type="scope.row.status === 1 ? 'success' : 'danger'">
              {{ scope.row.status === 1 ? '启用' : '禁用' }}
            </el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="createTime" label="创建时间" />
        <el-table-column label="操作" width="200">
          <template #default="scope">
            <el-button size="small" @click="handleEdit(scope.row)">编辑</el-button>
            <el-button 
              size="small" 
              type="danger" 
              @click="handleDelete(scope.row)"
            >
              删除
            </el-button>
          </template>
        </el-table-column>
      </el-table>
      
      <!-- 分页组件 -->
      <div class="pagination">
        <el-pagination
          v-model:current-page="pagination.currentPage"
          v-model:page-size="pagination.pageSize"
          :page-sizes="[10, 20, 50, 100]"
          :total="pagination.total"
          layout="total, sizes, prev, pager, next, jumper"
          @size-change="handleSizeChange"
          @current-change="handleCurrentChange"
        />
      </div>
    </el-card>
  </div>
</template>

<script setup>
import { ref, reactive, onMounted } from 'vue'
import { ElMessage, ElMessageBox } from 'element-plus'

// 响应式数据定义
const loading = ref(false)
const userList = ref([])

// 搜索表单数据
const searchForm = reactive({
  username: '',
  status: ''
})

// 分页数据
const pagination = reactive({
  currentPage: 1,
  pageSize: 10,
  total: 0
})

// 模拟用户数据
const mockUsers = [
  { id: 1, username: 'admin', email: 'admin@example.com', role: '管理员', status: 1, createTime: '2024-01-01' },
  { id: 2, username: 'user1', email: 'user1@example.com', role: '普通用户', status: 1, createTime: '2024-01-02' },
  { id: 3, username: 'user2', email: 'user2@example.com', role: '普通用户', status: 0, createTime: '2024-01-03' }
]

// 获取用户列表方法
// 作用：从服务器获取用户数据，支持分页和搜索条件
const getUserList = async () => {
  loading.value = true
  try {
    // 模拟API请求延迟
    await new Promise(resolve => setTimeout(resolve, 500))
    
    // 模拟数据过滤和分页
    let filteredUsers = [...mockUsers]
    
    if (searchForm.username) {
      filteredUsers = filteredUsers.filter(user => 
        user.username.includes(searchForm.username)
      )
    }
    
    if (searchForm.status !== '') {
      filteredUsers = filteredUsers.filter(user => 
        user.status == searchForm.status
      )
    }
    
    pagination.total = filteredUsers.length
    
    const start = (pagination.currentPage - 1) * pagination.pageSize
    const end = start + pagination.pageSize
    userList.value = filteredUsers.slice(start, end)
    
  } catch (error) {
    ElMessage.error('获取用户列表失败')
  } finally {
    loading.value = false
  }
}

// 搜索处理方法
// 作用：根据搜索条件重新获取用户列表
const handleSearch = () => {
  pagination.currentPage = 1
  getUserList()
}

// 重置搜索条件方法
// 作用：清空搜索条件并重新获取完整的用户列表
const handleReset = () => {
  searchForm.username = ''
  searchForm.status = ''
  pagination.currentPage = 1
  getUserList()
}

// 新增用户处理方法
// 作用：打开新增用户对话框或跳转到新增用户页面
const handleAddUser = () => {
  ElMessage.info('新增用户功能开发中...')
}

// 编辑用户处理方法
// 参数：row - 要编辑的用户数据对象
// 作用：打开编辑用户对话框或跳转到编辑用户页面
const handleEdit = (row) => {
  ElMessage.info(`编辑用户：${row.username}`)
}

// 删除用户处理方法
// 参数：row - 要删除的用户数据对象
// 作用：确认删除用户并更新列表
const handleDelete = async (row) => {
  try {
    await ElMessageBox.confirm(
      `确定要删除用户 "${row.username}" 吗？`,
      '删除确认',
      {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }
    )
    
    // 模拟删除操作
    ElMessage.success('删除成功')
    getUserList() // 重新获取列表
  } catch (error) {
    // 用户取消删除操作
  }
}

// 分页大小改变处理方法
// 参数：val - 新的每页显示数量
// 作用：更新分页大小并重新获取数据
const handleSizeChange = (val) => {
  pagination.pageSize = val
  pagination.currentPage = 1
  getUserList()
}

// 当前页改变处理方法
// 参数：val - 新的当前页码
// 作用：切换页码并重新获取数据
const handleCurrentChange = (val) => {
  pagination.currentPage = val
  getUserList()
}

// 组件挂载时获取数据
onMounted(() => {
  getUserList()
})
</script>

<style scoped>
.users-page {
  padding: 20px;
}

.page-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.page-header h1 {
  margin: 0;
  color: #333;
}

.search-card {
  margin-bottom: 20px;
}

.search-form {
  margin: 0;
}

.table-card {
  margin-bottom: 20px;
}

.pagination {
  display: flex;
  justify-content: flex-end;
  margin-top: 20px;
}
</style>
```

### 10.2 系统设置页面 (views/Settings.vue)



vue

```vue
<template>
  <div class="settings-page">
    <h1>系统设置</h1>
    
    <div class="settings-content">
      <!-- 基本设置 -->
      <el-card class="setting-card">
        <template #header>
          <span>基本设置</span>
        </template>
        
        <el-form :model="basicSettings" label-width="120px">
          <el-form-item label="系统名称">
            <el-input v-model="basicSettings.systemName" />
          </el-form-item>
          <el-form-item label="系统版本">
            <el-input v-model="basicSettings.version" disabled />
          </el-form-item>
          <el-form-item label="维护模式">
            <el-switch v-model="basicSettings.maintenanceMode" />
          </el-form-item>
          <el-form-item>
            <el-button type="primary" @click="saveBasicSettings">保存设置</el-button>
          </el-form-item>
        </el-form>
      </el-card>
      
      <!-- 安全设置 -->
      <el-card class="setting-card">
        <template #header>
          <span>安全设置</span>
        </template>
        
        <el-form :model="securitySettings" label-width="120px">
          <el-form-item label="密码强度">
            <el-select v-model="securitySettings.passwordStrength">
              <el-option label="低" value="low" />
              <el-option label="中" value="medium" />
              <el-option label="高" value="high" />
            </el-select>
          </el-form-item>
          <el-form-item label="会话超时">
            <el-input-number 
              v-model="securitySettings.sessionTimeout" 
              :min="10" 
              :max="1440"
            />
            <span style="margin-left: 10px;">分钟</span>
          </el-form-item>
          <el-form-item label="双因子认证">
            <el-switch v-model="securitySettings.twoFactorAuth" />
          </el-form-item>
          <el-form-item>
            <el-button type="primary" @click="saveSecuritySettings">保存设置</el-button>
          </el-form-item>
        </el-form>
      </el-card>
    </div>
  </div>
</template>

<script setup>
import { reactive } from 'vue'
import { ElMessage } from 'element-plus'

// 基本设置数据
const basicSettings = reactive({
  systemName: '管理系统',
  version: 'v1.0.0',
  maintenanceMode: false
})

// 安全设置数据
const securitySettings = reactive({
  passwordStrength: 'medium',
  sessionTimeout: 30,
  twoFactorAuth: false
})

// 保存基本设置方法
// 作用：保存系统基本配置信息
const saveBasicSettings = async () => {
  try {
    // 模拟保存操作
    await new Promise(resolve => setTimeout(resolve, 500))
    ElMessage.success('基本设置保存成功')
  } catch (error) {
    ElMessage.error('保存失败')
  }
}

// 保存安全设置方法
// 作用：保存系统安全相关配置
const saveSecuritySettings = async () => {
  try {
    // 模拟保存操作
    await new Promise(resolve => setTimeout(resolve, 500))
    ElMessage.success('安全设置保存成功')
  } catch (error) {
    ElMessage.error('保存失败')
  }
}
</script>

<style scoped>
.settings-page {
  padding: 20px;
}

.settings-page h1 {
  margin-bottom: 20px;
  color: #333;
}

.settings-content {
  display: grid;
  gap: 20px;
}

.setting-card {
  width: 100%;
  max-width: 600px;
}
</style>
```

## 11：工具函数

### 11.1 通用工具函数 (utils/index.js)

javascript

```javascript
/**
 * 格式化日期
 * @param {Date|string|number} date - 日期对象、字符串或时间戳
 * @param {string} format - 格式化模板，默认为 'YYYY-MM-DD HH:mm:ss'
 * @returns {string} 格式化后的日期字符串
 * 作用：统一日期格式化处理，支持多种输入格式
 */
export const formatDate = (date, format = 'YYYY-MM-DD HH:mm:ss') => {
  const d = new Date(date)
  if (isNaN(d.getTime())) return ''
  
  const year = d.getFullYear()
  const month = String(d.getMonth() + 1).padStart(2, '0')
  const day = String(d.getDate()).padStart(2, '0')
  const hours = String(d.getHours()).padStart(2, '0')
  const minutes = String(d.getMinutes()).padStart(2, '0')
  const seconds = String(d.getSeconds()).padStart(2, '0')
  
  return format
    .replace('YYYY', year)
    .replace('MM', month)
    .replace('DD', day)
    .replace('HH', hours)
    .replace('mm', minutes)
    .replace('ss', seconds)
}

/**
 * 防抖函数
 * @param {Function} func - 需要防抖的函数
 * @param {number} delay - 延迟时间（毫秒）
 * @returns {Function} 防抖后的函数
 * 作用：防止频繁触发事件，如搜索输入、按钮点击等
 */
export const debounce = (func, delay) => {
  let timeoutId
  return function (...args) {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(() => func.apply(this, args), delay)
  }
}

/**
 * 节流函数
 * @param {Function} func - 需要节流的函数
 * @param {number} limit - 时间间隔（毫秒）
 * @returns {Function} 节流后的函数
 * 作用：限制函数执行频率，如滚动事件处理
 */
export const throttle = (func, limit) => {
  let inThrottle
  return function (...args) {
    if (!inThrottle) {
      func.apply(this, args)
      inThrottle = true
      setTimeout(() => inThrottle = false, limit)
    }
  }
}

/**
 * 深拷贝对象
 * @param {any} obj - 需要拷贝的对象
 * @returns {any} 拷贝后的对象
 * 作用：创建对象的完全独立副本，避免引用问题
 */
export const deepClone = (obj) => {
  if (obj === null || typeof obj !== 'object') return obj
  if (obj instanceof Date) return new Date(obj.getTime())
  if (obj instanceof Array) return obj.map(item => deepClone(item))
  
  const clonedObj = {}
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      clonedObj[key] = deepClone(obj[key])
    }
  }
  return clonedObj
}

/**
 * 生成唯一ID
 * @returns {string} 唯一标识符
 * 作用：生成组件或数据的唯一标识
 */
export const generateId = () => {
  return Date.now().toString(36) + Math.random().toString(36).substr(2)
}

/**
 * 存储操作封装
 * 作用：统一本地存储操作，提供错误处理
 */
export const storage = {
  // 设置存储项
  set(key, value) {
    try {
      localStorage.setItem(key, JSON.stringify(value))
    } catch (error) {
      console.error('存储设置失败:', error)
    }
  },
  
  // 获取存储项
  get(key, defaultValue = null) {
    try {
      const item = localStorage.getItem(key)
      return item ? JSON.parse(item) : defaultValue
    } catch (error) {
      console.error('存储获取失败:', error)
      return defaultValue
    }
  },
  
  // 移除存储项
  remove(key) {
    try {
      localStorage.removeItem(key)
    } catch (error) {
      console.error('存储移除失败:', error)
    }
  },
  
  // 清空所有存储
  clear() {
    try {
      localStorage.clear()
    } catch (error) {
      console.error('存储清空失败:', error)
    }
  }
}
```

## 12：项目配置文件

### 12.1 Vite配置 (vite.config.js)



javascript

```javascript
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

// Vite配置
// 作用：配置Vite构建工具的各项参数，包括插件、路径别名、服务器等
export default defineConfig({
  // 插件配置
  plugins: [
    vue() // Vue3支持插件
  ],

  // 路径别名配置
  // 作用：简化导入路径，提高开发效率
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
      '@components': resolve(__dirname, 'src/components'),
      '@views': resolve(__dirname, 'src/views'),
      '@stores': resolve(__dirname, 'src/stores'),
      '@utils': resolve(__dirname, 'src/utils')
    }
  },

  // 开发服务器配置
  server: {
    port: 3000,        // 开发服务器端口
    open: true,        // 自动打开浏览器
    cors: true,        // 启用CORS
    proxy: {
      // API代理配置，用于解决开发环境跨域问题
      '/api': {
        target: 'http://localhost:8080/mrsp_server',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  },

  // 构建配置
  build: {
    outDir: 'dist',           // 构建输出目录
    assetsDir: 'assets',      // 静态资源目录
    sourcemap: false,         // 是否生成source map
    minify: 'terser',         // 压缩方式
    rollupOptions: {
      output: {
        // 分包策略，优化加载性能
        manualChunks: {
          vue: ['vue', 'vue-router', 'pinia'],
          elementPlus: ['element-plus'],
          utils: ['lodash', 'axios']
        }
      }
    }
  }
})
```

# 优化Http请求方法

## utils/request.js

我将帮您将这个Vue组件中的axios调用重构为使用request.js工具类。首先，让我创建一个标准的request.js工具类，然后修改您的组件代码。

~~~ js
import axios from 'axios'
import { ElMessage } from 'element-plus'

// 创建axios实例
const request = axios.create({
  baseURL: '/api', // 基础URL
  timeout: 10000,  // 请求超时时间
  headers: {
    'Content-Type': 'application/json;charset=UTF-8'
  }
})

// 请求拦截器
request.interceptors.request.use(
  config => {
    // 在发送请求之前做些什么
    // 可以在这里添加token等认证信息
    // const token = getToken()
    // if (token) {
    //   config.headers.Authorization = `Bearer ${token}`
    // }
    return config
  },
  error => {
    // 对请求错误做些什么
    console.error('请求错误:', error)
    return Promise.reject(error)
  }
)

// 响应拦截器
request.interceptors.response.use(
  response => {
    // 对响应数据做点什么
    const res = response.data
    
    // 根据业务逻辑处理响应
    if (res.processResult === 'SUCCESS') {
      return res
    } else if (res.processResult === 'FAILED') {
      ElMessage.error(res.errorMessage || '请求失败')
      return Promise.reject(new Error(res.errorMessage || '请求失败'))
    }
    
    return res
  },
  error => {
    // 对响应错误做点什么
    console.error('响应错误:', error)
    
    // 处理HTTP状态码错误
    let message = '请求失败'
    if (error.response) {
      switch (error.response.status) {
        case 401:
          message = '未授权，请重新登录'
          break
        case 403:
          message = '拒绝访问'
          break
        case 404:
          message = '请求地址出错'
          break
        case 408:
          message = '请求超时'
          break
        case 500:
          message = '服务器内部错误'
          break
        case 501:
          message = '服务未实现'
          break
        case 502:
          message = '网关错误'
          break
        case 503:
          message = '服务不可用'
          break
        case 504:
          message = '网关超时'
          break
        case 505:
          message = 'HTTP版本不受支持'
          break
        default:
          message = `连接错误${error.response.status}`
      }
    } else if (error.code === 'ECONNABORTED') {
      message = '请求超时'
    } else if (error.message.includes('Network Error')) {
      message = '网络连接异常'
    }
    
    ElMessage.error(message)
    return Promise.reject(error)
  }
)

// 封装常用的请求方法
const http = {
  get(url, params = {}) {
    return request({
      method: 'get',
      url,
      params
    })
  },

  post(url, data = {}) {
    return request({
      method: 'post',
      url,
      data
    })
  },

  put(url, data = {}) {
    return request({
      method: 'put',
      url,
      data
    })
  },

  delete(url, params = {}) {
    return request({
      method: 'delete',
      url,
      params
    })
  },

  // 文件上传
  upload(url, formData) {
    return request({
      method: 'post',
      url,
      data: formData,
      headers: {
        'Content-Type': 'multipart/form-data'
      }
    })
  }
}

export default http
~~~

## api/userApi.js

~~~ js
import http from '@/utils/request.js'

/**
 * 用户API服务
 */
export const userApi = {
  /**
   * 分页查询用户列表
   * @param {Object} params 查询参数
   * @returns {Promise}
   */
  getUserListByPage(params) {
    return http.get('/users/doUserListByPage', params)
  },

  /**
   * 根据ID查询用户信息
   * @param {String|Number} id 用户ID
   * @returns {Promise}
   */
  getUserById(id) {
    return http.get(`/users/doFindUserById/${id}`)
  },

  /**
   * 添加用户
   * @param {Object} userData 用户数据
   * @returns {Promise}
   */
  addUser(userData) {
    return http.post('/users/doUserAddSave', userData)
  },

  /**
   * 更新用户
   * @param {Object} userData 用户数据
   * @returns {Promise}
   */
  updateUser(userData) {
    return http.put('/users/doUserEditSave', userData)
  },

  /**
   * 删除用户
   * @param {String|Number} id 用户ID
   * @returns {Promise}
   */
  deleteUser(id) {
    return http.delete(`/users/doUserDelete/${id}`)
  },

  /**
   * 批量删除用户
   * @param {Array} ids 用户ID数组
   * @returns {Promise}
   */
  batchDeleteUsers(ids) {
    return http.delete('/users/doBatchDelete', { ids })
  },

  /**
   * 更新用户状态
   * @param {String|Number} id 用户ID
   * @param {Number} status 状态值
   * @returns {Promise}
   */
  updateUserStatus(id, status) {
    return http.put(`/users/doUpdateStatus/${id}`, { status })
  },

  /**
   * 重置用户密码
   * @param {String|Number} id 用户ID
   * @param {String} newPassword 新密码
   * @returns {Promise}
   */
  resetPassword(id, newPassword) {
    return http.put(`/users/doResetPassword/${id}`, { password: newPassword })
  },

  /**
   * 上传头像
   * @param {FormData} formData 文件数据
   * @returns {Promise}
   */
  uploadAvatar(formData) {
    return http.upload('/upload/avatar', formData)
  }
}

export default userApi
~~~

## views/Users.vue

- 编写script脚本

~~~ vue
<script setup>
import userApi from '@/api/userApi.js' // 导入用户API服务
import { onMounted, ref, toRefs, reactive } from "vue";
import { ElMessage, ElMessageBox } from "element-plus";

// 表单引用，用于表单验证
const userFormRef = ref();
const open = ref(false);     // 控制对话框的打开/关闭状态
const title = ref("");       // 对话框标题
const total = ref(0) //总记录条数

const data = reactive({
  userform: {               // 用户表单数据
    id: null,
    username: null,
    email: null,
    password: null,
    nickname: null,
    avatarUrl: '',
    role: null,
    status: null
  },
  queryParams: {            // 查询参数（用于分页和搜索）
    pageNum: 1,
    pageSize: 10,
    username: null,
    email: null,
    password: null,
    nickname: null,
    role: null,
    status: null,
  },
  rules: {
    username: [
      { required: true, message: '用户名不能为空', trigger: 'blur' },
      { min: 3, max: 20, message: '用户名长度应在3-20个字符之间', trigger: 'blur' },
      { pattern: /^[a-zA-Z0-9_]+$/, message: '用户名只能包含字母、数字和下划线', trigger: 'blur' }
    ],
    email: [
      { required: true, message: '邮箱不能为空', trigger: 'blur' },
      { type: 'email', message: '请输入正确的邮箱格式', trigger: ['blur', 'change'] }
    ],
    password: [
      { required: true, message: '密码不能为空', trigger: 'blur' },
      { min: 6, max: 20, message: '密码长度应在6-20个字符之间', trigger: 'blur' },
      {
        pattern: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]{6,}$/,
        message: '密码必须包含至少一个大写字母、一个小写字母和一个数字',
        trigger: 'blur'
      }
    ],
    nickname: [
      { required: true, message: '昵称不能为空', trigger: 'blur' },
      { min: 2, max: 10, message: '昵称长度应在2-10个字符之间', trigger: 'blur' }
    ],
    role: [
      { required: true, message: '请选择角色', trigger: 'change' }
    ],
    status: [
      { required: true, message: '请选择状态', trigger: 'change' }
    ]
  }
});

const { queryParams, userform, rules } = toRefs(data);

// 重置表单
function reset() {
  userform.value = {
    id: null,
    username: null,
    email: null,
    password: null,
    nickname: null,
    avatarUrl: '',
    role: null,
    status: null
  };
}

// 添加用户处理
function handleAdd() {
  reset();
  open.value = true;
  title.value = "添加用户";
}

// 取消按钮
function cancel() {
  open.value = false;
  reset();
}

// 编辑用户
const doEdit = async (currentLineData) => {
  reset();
  const _id = currentLineData.id;

  try {
    const response = await userApi.getUserById(_id);
    userform.value = response.queryResultData;
    open.value = true;
    title.value = "修改用户";
  } catch (error) {
    console.error('获取用户信息失败:', error);
  }
}

// 表单提交
function submitForm() {
  if (!userFormRef.value) return;

  userFormRef.value.validate((valid, fields) => {
    if (valid) {
      if (userform.value.id != null) {
        updateUserSave();
      } else {
        addUserSave();
      }
    } else {
      ElMessage.error('请检查表单填写是否正确');
      console.log('表单验证失败:', fields);
    }
  });
}

// 添加用户
const addUserSave = async () => {
  try {
    await userApi.addUser(userform.value);
    ElMessage.success('添加用户成功！');
    open.value = false;
    loadUserlist();
  } catch (error) {
    console.error('添加用户失败:', error);
  }
}

// 更新用户
const updateUserSave = async () => {
  try {
    await userApi.updateUser(userform.value);
    ElMessage.success('更新用户成功！');
    open.value = false;
    loadUserlist();
  } catch (error) {
    console.error('更新用户失败:', error);
  }
}

// 用户列表
let userlist = ref([]);

// 加载用户列表
const loadUserlist = async () => {
  try {
    const response = await userApi.getUserListByPage(queryParams.value);
    userlist.value = response.queryResultData.records;
    total.value = response.queryResultData.total;
    ElMessage.success('加载列表成功！');
  } catch (error) {
    console.error('加载用户列表失败:', error);
  }
}

// 删除用户
const handleDelete = async (row) => {
  try {
    await ElMessageBox.confirm(
        `确定要删除用户"${row.username}"吗？`,
        '删除确认',
        {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning',
        }
    );

    await userApi.deleteUser(row.id);
    ElMessage.success('删除成功！');
    loadUserlist();
  } catch (error) {
    if (error === 'cancel') {
      ElMessage.info('已取消删除');
    } else {
      console.error('删除用户失败:', error);
    }
  }
}

// 更新用户状态
const handleStatusChange = async (row) => {
  try {
    await userApi.updateUserStatus(row.id, row.status);
    ElMessage.success('状态更新成功！');
  } catch (error) {
    console.error('状态更新失败:', error);
    // 恢复原状态
    loadUserlist();
  }
}

onMounted(() => {
  loadUserlist();
});

// 角色选项
const roleOptions = [
  { label: '管理员', value: 'admin' },
  { label: '普通用户', value: 'user' },
  { label: '访客', value: 'guest' }
];

// 状态选项
const statusOptions = [
  { label: '正常', value: 1 },
  { label: '禁用', value: 0 },
  { label: '待审核', value: 2 }
];

// 上传相关配置
const uploadAction = '/api/upload/avatar'
const uploadHeaders = {}

// 头像上传成功回调
const handleAvatarSuccess = (response, file) => {
  if (response.processResult === "SUCCESS") {
    userform.value.avatarUrl = response.queryResultData;
    ElMessage.success('头像上传成功！')
  } else {
    ElMessage.error(response.message || '头像上传失败！')
  }
}

// 头像上传前验证
const beforeAvatarUpload = (file) => {
  const isJPGOrPNG = file.type === 'image/jpeg' || file.type === 'image/png'
  const isLt2M = file.size / 1024 / 1024 < 2

  if (!isJPGOrPNG) {
    ElMessage.error('头像图片只能是 JPG 或 PNG 格式!')
    return false
  }
  if (!isLt2M) {
    ElMessage.error('头像图片大小不能超过 2MB!')
    return false
  }
  return true
}

// 查询操作
const handleQuery = () => {
  queryParams.value.pageNum = 1
  loadUserlist()
}

// 重置查询条件
const handleReset = () => {
  queryParams.value.username = ''
  queryParams.value.role = ''
  queryParams.value.status = null
  queryParams.value.pageNum = 1
  loadUserlist()
}

// 分页大小变化
const handleSizeChange = (val) => {
  queryParams.value.pageSize = val
  queryParams.value.pageNum = 1
  loadUserlist()
}

// 当前页变化
const handleCurrentChange = (val) => {
  queryParams.value.pageNum = val
  loadUserlist()
}
</script>
~~~

`await` 关键字的作用是：

1. **暂停执行**当前的 `async` 函数，直到 `userApi.addUser(userform.value)` 这个异步操作完成。
2. 如果该操作成功（Promise 变为 `fulfilled`），返回其结果。
3. 如果该操作失败（Promise 变为 `rejected`），则抛出异常，会进入 `catch` 块。

