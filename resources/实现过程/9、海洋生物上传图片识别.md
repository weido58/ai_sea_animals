# 如何通过阿里云百练识别图片

https://bailian.console.aliyun.com/console?spm=5176.29677750.nav-v2-dropdown-menu-0.d_main_0_0.3141154a0ODGGy&tab=home&scm=20140722.M_10774053._.V_1#/home

![image-20250622225752243](assets/image-20250622225752243.png)



~~~ java
package com.marine;

import java.util.Arrays;
import java.util.Collections;
import com.alibaba.dashscope.aigc.multimodalconversation.MultiModalConversation;
import com.alibaba.dashscope.aigc.multimodalconversation.MultiModalConversationParam;
import com.alibaba.dashscope.aigc.multimodalconversation.MultiModalConversationResult;
import com.alibaba.dashscope.common.MultiModalMessage;
import com.alibaba.dashscope.common.Role;
import com.alibaba.dashscope.exception.ApiException;
import com.alibaba.dashscope.exception.NoApiKeyException;
import com.alibaba.dashscope.exception.UploadFileException;
import com.alibaba.dashscope.utils.JsonUtils;

public class SimpleMultiModalConversationCall {
    public static void simpleMultiModalConversationCall()
            throws ApiException, NoApiKeyException, UploadFileException {
        MultiModalConversation conv = new MultiModalConversation();
        MultiModalMessage userMessage = MultiModalMessage.builder().role(Role.USER.getValue())
                .content(Arrays.asList(
                        Collections.singletonMap("image", "https://dashscope.oss-cn-beijing.aliyuncs.com/images/dog_and_girl.jpeg"),
                        Collections.singletonMap("image", "https://dashscope.oss-cn-beijing.aliyuncs.com/images/tiger.png"),
                        Collections.singletonMap("image", "https://dashscope.oss-cn-beijing.aliyuncs.com/images/rabbit.png"),
                        Collections.singletonMap("text", "这些是什么?"))).build();
        MultiModalConversationParam param = MultiModalConversationParam.builder()
                // 若没有配置环境变量，请用百炼API Key将下行替换为：.apiKey("sk-xxx")
                .apiKey("sk-6006411787c44403a00bc0135119a547")
                // 此处以qwen-vl-plus为例，可按需更换模型名称。模型列表：https://help.aliyun.com/zh/model-studio/getting-started/models
                .model("qwen-vl-plus")
                .message(userMessage)
                .build();
        MultiModalConversationResult result = conv.call(param);
        System.out.println(JsonUtils.toJson(result));
    }

    public static void main(String[] args) {
        try {
            simpleMultiModalConversationCall();
        } catch (ApiException | NoApiKeyException | UploadFileException e) {
            System.out.println(e.getMessage());
        }
        System.exit(0);
    }
}
~~~



这是一个使用阿里云百炼（DashScope）平台进行多模态对话的Java代码示例。让我详细解释各个部分：

导入依赖



java

```java
import com.alibaba.dashscope.aigc.multimodalconversation.*; // 多模态对话相关类
import com.alibaba.dashscope.common.*; // 通用类如消息、角色
import com.alibaba.dashscope.exception.*; // 异常处理类
```

这些是阿里云DashScope SDK的核心包，用于处理多模态AI对话。

核心方法 `simpleMultiModalConversationCall()`

1. 创建对话实例



java

```java
MultiModalConversation conv = new MultiModalConversation();
```

创建多模态对话的客户端实例。

2. 构建用户消息



java

```java
MultiModalMessage userMessage = MultiModalMessage.builder()
    .role(Role.USER.getValue())
    .content(Arrays.asList(
        Collections.singletonMap("image", "图片URL1"),
        Collections.singletonMap("image", "图片URL2"), 
        Collections.singletonMap("image", "图片URL3"),
        Collections.singletonMap("text", "这些是什么?")
    )).build();
```

这里构建了一个包含多种内容类型的消息：

- **角色设置**：`Role.USER` 表示这是用户发送的消息
- 多模态内容：包含3张图片和1个文本问题
  - 第1张图片：狗和女孩的照片
  - 第2张图片：老虎图片
  - 第3张图片：兔子图片
  - 文本问题：询问"这些是什么?"

3. 配置对话参数



java

```java
MultiModalConversationParam param = MultiModalConversationParam.builder()
    .apiKey(System.getenv("DASHSCOPE_API_KEY")) // 从环境变量获取API密钥
    .model("qwen-vl-plus") // 使用通义千问视觉增强版模型
    .message(userMessage) // 传入用户消息
    .build();
```

参数配置包括：

- **API密钥**：通过环境变量`DASHSCOPE_API_KEY`获取
- **模型选择**：使用`qwen-vl-plus`（通义千问视觉增强版）
- **消息内容**：传入刚构建的多模态消息

4. 调用API并输出结果



java

```java
MultiModalConversationResult result = conv.call(param);
System.out.println(JsonUtils.toJson(result));
```

发送请求到DashScope API，并将返回结果以JSON格式打印输出。

主方法和异常处理



java

```java
public static void main(String[] args) {
    try {
        simpleMultiModalConversationCall();
    } catch (ApiException | NoApiKeyException | UploadFileException e) {
        System.out.println(e.getMessage());
    }
    System.exit(0);
}
```

主方法中调用核心功能，并处理可能出现的异常：

- `ApiException`：API调用异常
- `NoApiKeyException`：API密钥缺失异常
- `UploadFileException`：文件上传异常

代码功能总结

这个程序的作用是：

1. 向AI模型发送3张不同的图片（狗和女孩、老虎、兔子）
2. 同时询问"这些是什么？"
3. AI模型会分析这些图片并用中文回答图片内容
4. 结果以JSON格式返回并打印

这是一个典型的多模态AI应用场景，展示了如何同时处理图像和文本输入，让AI理解并描述图片内容。

# 海洋生物识别系统

## 1. 配置pom文件

~~~ xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.gec</groupId>
    <artifactId>marine-species-recognition</artifactId>
    <version>1.0-SNAPSHOT</version>


    <!-- 指定spring boot父工程 -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.6</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <druid.version>1.2.9</druid.version>
        <mybatis-spring-boot-starter.version>3.0.3</mybatis-spring-boot-starter.version>
        <mysql-connector.version>8.0.29</mysql-connector.version>
        <mybatis-plus.version>3.5.6</mybatis-plus.version>
        <mybatis.version>3.5.16</mybatis.version>
        <!-- LangChain4j版本号，使用变量便于统一管理 -->
        <langchain4j.verion>1.0.0-beta1</langchain4j.verion>
    </properties>

    <dependencies>

        <!-- Spring Boot Web Starter -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>${mybatis.version}</version>
        </dependency>

        <!--集成druid连接池-->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
            <version>${druid.version}</version>
        </dependency>
        <!--Mysql数据库驱动-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>${mysql-connector.version}</version>
        </dependency>

        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-spring-boot3-starter</artifactId>
            <version>${mybatis-plus.version}</version>
        </dependency>

        <!-- MyBatis-Plus -->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus</artifactId>
            <version>${mybatis-plus.version}</version>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>

        <!-- 文件上传处理 -->
        <dependency>
            <groupId>commons-fileupload</groupId>
            <artifactId>commons-fileupload</artifactId>
            <version>1.4</version>
        </dependency>

        <!-- Apache Commons IO -->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>2.11.0</version>
        </dependency>

        <!-- HTTP客户端 -->
        <dependency>
            <groupId>org.apache.httpcomponents</groupId>
            <artifactId>httpclient</artifactId>
            <version>4.5.14</version>
        </dependency>

        <!-- Validation -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <!-- LangChain4j 核心依赖 -->
        <dependency>
            <groupId>dev.langchain4j</groupId>
            <artifactId>langchain4j</artifactId>
            <version>${langchain4j.verion}</version>
        </dependency>
        <!-- 向量存储 -->
        <dependency>
            <groupId>dev.langchain4j</groupId>
            <artifactId>langchain4j-embeddings-all-minilm-l6-v2</artifactId>
            <version>${langchain4j.verion}</version>
        </dependency>

        <dependency>
            <groupId>dev.langchain4j</groupId>
            <artifactId>langchain4j-open-ai-spring-boot-starter</artifactId>
            <version>${langchain4j.verion}</version>
        </dependency>
        <dependency>
            <groupId>dev.langchain4j</groupId>
            <artifactId>langchain4j-community-dashscope-spring-boot-starter</artifactId>
            <version>${langchain4j.verion}</version>
            <exclusions>
                <exclusion>
                    <groupId>org.slf4j</groupId>
                    <artifactId>slf4j-simple</artifactId>
                </exclusion>
            </exclusions>
        </dependency>


        <!-- Spring Boot Thymeleaf -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <!-- Spring Boot Maven 插件，用于打包和运行 Spring Boot 应用 -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
~~~

## 2. MarineSpecies实体类

~~~ java
package com.marine.entity;

import com.baomidou.mybatisplus.annotation.*;
import lombok.Data;
import lombok.experimental.Accessors;
import java.time.LocalDateTime;

/**
 * 海洋生物基础信息实体类
 */
@Data
@Accessors(chain = true)
@TableName("marine_species")
public class MarineSpecies {

    /**
     * 主键ID
     */
    @TableId(value = "id", type = IdType.AUTO)
    private Long id;

    /**
     * 学名
     */
    @TableField("scientific_name")
    private String scientificName;

    /**
     * 俗名
     */
    @TableField("common_name")
    private String commonName;

    /**
     * 中文名
     */
    @TableField("chinese_name")
    private String chineseName;

    /**
     * 分类信息(JSON格式)
     */
    @TableField("classification")
    private String classification;

    /**
     * 栖息地描述
     */
    @TableField("habitat")
    private String habitat;

    /**
     * 分布区域
     */
    @TableField("distribution")
    private String distribution;

    /**
     * 特征描述
     */
    @TableField("characteristics")
    private String characteristics;

    /**
     * 体型范围
     */
    @TableField("size_range")
    private String sizeRange;

    /**
     * 食性
     */
    @TableField("diet")
    private String diet;

    /**
     * 保护状态
     */
    @TableField("conservation_status")
    private String conservationStatus;

    /**
     * 参考图片URLs(JSON数组)
     */
    @TableField("image_urls")
    private String imageUrls;

    /**
     * 详细描述
     */
    @TableField("description")
    private String description;

    /**
     * 创建时间
     */
    @TableField(value = "created_time", fill = FieldFill.INSERT)
    private LocalDateTime createdTime;

    /**
     * 更新时间
     */
    @TableField(value = "updated_time", fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updatedTime;

    /**
     * 是否删除 0-否 1-是
     */
    @TableField("is_deleted")
    @TableLogic
    private Integer isDeleted;
}
~~~

## 3. QwenRecognitionDTO实体类

~~~ java
package com.marine.dto;


import lombok.Data;
import lombok.experimental.Accessors;

/**
 * 千问识别结果DTO
 */
@Data
@Accessors(chain = true)
public class QwenRecognitionDTO {

    /**
     * 学名
     */
    private String scientificName;

    /**
     * 俗名
     */
    private String commonName;

    /**
     * 中文名
     */
    private String chineseName;

    /**
     * 分类信息
     */
    private ClassificationInfo classification;

    /**
     * 栖息地描述
     */
    private String habitat;

    /**
     * 分布区域
     */
    private String distribution;

    /**
     * 特征描述
     */
    private String characteristics;

    /**
     * 体型范围
     */
    private String sizeRange;

    /**
     * 食性
     */
    private String diet;

    /**
     * 保护状态
     */
    private String conservationStatus;

    /**
     * 详细描述
     */
    private String description;

    /**
     * 置信度
     */
    private Double confidence;

    @Data
    @Accessors(chain = true)
    public static class ClassificationInfo {
        private String kingdom;   // 界
        private String phylum;    // 门
        private String clazz;     // 纲
        private String order;     // 目
        private String family;    // 科
        private String genus;     // 属
        private String species;   // 种
    }
}
~~~

## 4. MarineSpeciesMapper

~~~ java
package com.marine.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.marine.entity.MarineSpecies;
import org.apache.ibatis.annotations.Mapper;

/**
 * 海洋生物数据访问层
 */
@Mapper
public interface MarineSpeciesMapper extends BaseMapper<MarineSpecies> {
}
~~~

## 5. MyBatisPlusConfig配置类

~~~ java
package com.marine.config;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.apache.ibatis.reflection.MetaObject;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.LocalDateTime;

/**
 * MyBatisPlus配置
 */
@Configuration
public class MyBatisPlusConfig implements MetaObjectHandler {

    /**
     * 分页插件
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }

    /**
     * 插入时填充
     */
    @Override
    public void insertFill(MetaObject metaObject) {
        this.strictInsertFill(metaObject, "createdTime", LocalDateTime.class, LocalDateTime.now());
        this.strictInsertFill(metaObject, "updatedTime", LocalDateTime.class, LocalDateTime.now());
    }

    /**
     * 更新时填充
     */
    @Override
    public void updateFill(MetaObject metaObject) {
        this.strictUpdateFill(metaObject, "updatedTime", LocalDateTime.class, LocalDateTime.now());
    }
}
~~~

## 6. StaticResourceConfig配置类

~~~ java
package com.marine.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 静态资源配置
 */
@Configuration
public class StaticResourceConfig implements WebMvcConfigurer {

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        // 配置上传图片的访问路径
        registry.addResourceHandler("/uploads/**")
                .addResourceLocations("file:uploads/");
        // 配置静态资源
        registry.addResourceHandler("/static/**")
                .addResourceLocations("classpath:/static/");
    }
}
~~~

## 7. QwenVisionService服务类

### 类概述

`QwenVisionService` 是一个基于Spring Boot的服务类，专门用于调用阿里巴巴的千问（Qwen）视觉识别API来识别海洋生物图片。该服务封装了完整的图像识别流程，从图片预处理到API调用，再到结果解析。

### 主要作用

1. **海洋生物图片识别**：专门针对海洋生物图片进行AI识别
2. **多模态处理**：支持图片+文本的多模态AI交互
3. **结构化数据返回**：将识别结果转换为标准化的数据传输对象
4. **异常处理**：提供完善的错误处理和默认响应机制

~~~ java
package com.marine.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.marine.dto.QwenRecognitionDTO;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.codec.binary.Base64;
import org.apache.http.HttpEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 阿里千问视觉识别服务
 */
@Service
@Slf4j
public class QwenVisionService {

    @Value("${qwen.api.key}")
    private String apiKey;

    @Value("${qwen.api.endpoint}")
    private String endpoint;

    @Value("${qwen.api.model}")
    private String model;

    private final ObjectMapper objectMapper = new ObjectMapper();

    /**
     * 识别海洋生物图片
     */
    public QwenRecognitionDTO recognizeMarineSpecies(MultipartFile imageFile) throws IOException {
        // 将图片转换为Base64
        String base64Image = Base64.encodeBase64String(imageFile.getBytes());

        // 直接构建正确格式的请求体
        Map<String, Object> requestBody = buildCorrectRequestBody(base64Image);


        String jsonRequestBody = objectMapper.writeValueAsString(requestBody);
        // 发送请求到千问API
        String response = sendRequest(requestBody);

        // 解析响应并提取生物信息
        return parseResponse(response);
    }

    /**
     * 构建符合千问API格式的请求体
     */
    private Map<String, Object> buildCorrectRequestBody(String base64Image) {
        Map<String, Object> requestBody = new HashMap<>();

        // 设置模型
        requestBody.put("model", model != null ? model : "qwen-vl-plus");

        // 构建 input 部分
        Map<String, Object> input = new HashMap<>();
        List<Map<String, Object>> messages = new ArrayList<>();

        Map<String, Object> userMessage = new HashMap<>();
        userMessage.put("role", "user");

        List<Map<String, Object>> content = new ArrayList<>();

        // 添加文本内容
        Map<String, Object> textContent = new HashMap<>();
        textContent.put("text", buildPrompt());
        content.add(textContent);

        // 添加图像内容
        Map<String, Object> imageContent = new HashMap<>();
        imageContent.put("image", "data:image/jpeg;base64," + base64Image);
        content.add(imageContent);

        userMessage.put("content", content);
        messages.add(userMessage);

        input.put("messages", messages);
        requestBody.put("input", input);

        // 构建 parameters 部分
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("max_tokens", 2000);
        parameters.put("temperature", 0.1);
        parameters.put("top_p", 0.8);

        requestBody.put("parameters", parameters);

        return requestBody;
    }

    /**
     * 构建识别提示词
     */
    private String buildPrompt() {
        return """
        请仔细分析这张海洋生物图片，并以JSON格式返回详细信息。请严格按照以下JSON结构返回：
        {
            "scientificName": "学名",
            "commonName": "英文俗名", 
            "chineseName": "中文名",
            "classification": {
                "kingdom": "界",
                "phylum": "门",
                "clazz": "纲",
                "order": "目",
                "family": "科",
                "genus": "属",
                "species": "种"
            },
            "habitat": "栖息地描述",
            "distribution": "分布区域",
            "characteristics": "特征描述",
            "sizeRange": "体型范围",
            "diet": "食性",
            "conservationStatus": "保护状态",
            "description": "详细描述",
            "confidence": 0.95
        }
        
        如果无法确定具体种类，请标注"confidence"较低的值，并在相应字段中标注"未确定"或"疑似"。
        请只返回JSON数据，不要包含其他文字说明。
        """;
    }

    /**
     * 发送HTTP请求 - 改进版本
     */
    private String sendRequest(Map<String, Object> requestBody) throws IOException {
        try (CloseableHttpClient httpClient = HttpClients.createDefault()) {
            HttpPost httpPost = new HttpPost(endpoint);

            // 设置请求头
            httpPost.setHeader("Authorization", "Bearer " + apiKey);
            httpPost.setHeader("Content-Type", "application/json");

            // 序列化请求体
            String jsonBody = objectMapper.writeValueAsString(requestBody);
            httpPost.setEntity(new StringEntity(jsonBody, "UTF-8"));

            // 打印简要请求信息（避免记录完整图片数据）
            log.info("发送请求到千问API，请求体大小: {} bytes", jsonBody.length());

            // 安全打印 model 和 messages 结构
            Object inputObj = requestBody.get("input");
            if (inputObj instanceof Map) {
                Map<?, ?> inputMap = (Map<?, ?>) inputObj;
                Object messagesObj = inputMap.get("messages");
                if (messagesObj instanceof List) {
                    log.debug("请求结构: model={}, messages.size={}",
                            requestBody.get("model"),
                            ((List<?>) messagesObj).size());
                } else {
                    log.debug("请求结构: model={}, messages=未找到或格式错误", requestBody.get("model"));
                }
            } else {
                log.debug("请求结构: model={}, input=未找到或格式错误", requestBody.get("model"));
            }

            // 发送请求并获取响应
            try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
                HttpEntity entity = response.getEntity();
                String responseBody = EntityUtils.toString(entity, "UTF-8");

                log.info("千问API响应状态: {}", response.getStatusLine().getStatusCode());
                log.debug("千问API响应: {}", responseBody);

                if (response.getStatusLine().getStatusCode() != 200) {
                    throw new RuntimeException("API请求失败: " + responseBody);
                }

                return responseBody;
            }
        }
    }

    /**
     * 解析API响应 - 修复响应结构解析（适配 Qwen-VL 多模态模型）
     */
    private QwenRecognitionDTO parseResponse(String response) {
        try {

            System.out.println(response);
            JsonNode rootNode = objectMapper.readTree(response);

            String content = null;

            // 尝试各种可能的响应结构路径（按优先级排序）

            // 尝试按 DashScope Qwen-VL 格式提取 content.text 字段
            if (rootNode.has("output")) {
                JsonNode choicesNode = rootNode.path("output").path("choices");
                if (choicesNode.isArray() && choicesNode.size() > 0) {
                    JsonNode firstChoice = choicesNode.get(0);
                    JsonNode contentArray = firstChoice.path("message").path("content");
                    if (contentArray.isArray() && contentArray.size() > 0) {
                        JsonNode textNode = contentArray.get(0).path("text");
                        if (textNode.isTextual()) {
                            content = textNode.asText();
                        }
                    }
                }
            }

            System.out.println("提取的内容是：");
            System.out.println(content);

            // 2. OpenAI 风格（备用兼容）
            if (content == null && rootNode.has("choices")) {
                JsonNode choicesNode = rootNode.path("choices");
                if (choicesNode.isArray() && !choicesNode.isEmpty()) {
                    JsonNode messageNode = choicesNode.get(0).path("message");
                    if (messageNode.has("content")) {
                        content = messageNode.path("content").asText();
                    }
                }
            }
            // 3. 其他可能的格式（如旧版接口）
            if (content == null && rootNode.has("result")) {
                content = rootNode.path("result").path("response").asText();
            }
            // 如果仍然无法获取 content
            if (content == null || content.trim().isEmpty()) {
                log.warn("无法找到响应内容，响应结构: {}", rootNode.toString());
                return createDefaultResponse();
            }


            log.info("千问返回内容长度: {}", content.length());
            log.debug("千问返回内容: {}", content);

            // 提取JSON部分（如果响应中有非JSON内容包裹）
            String jsonContent = extractJsonFromContent(content);
            log.debug("提取的JSON: {}", jsonContent);

            // 解析JSON为DTO
            return objectMapper.readValue(jsonContent, QwenRecognitionDTO.class);

        } catch (Exception e) {
            log.error("解析千问响应失败: {}", e.getMessage(), e);
            return createDefaultResponse();
        }
    }

    /**
     * 从内容中提取JSON - 增强版本
     */
    private String extractJsonFromContent(String content) {
        if (content == null || content.trim().isEmpty()) {
            return createDefaultJsonResponse();
        }

        // 移除可能的markdown代码块标记
        content = content.replaceAll("```json\\s*", "").replaceAll("```\\s*", "");

        // 查找JSON开始和结束位置
        int startIndex = content.indexOf("{");
        int endIndex = content.lastIndexOf("}");

        if (startIndex != -1 && endIndex != -1 && endIndex > startIndex) {
            String jsonContent = content.substring(startIndex, endIndex + 1);

            // 验证JSON格式
            try {
                objectMapper.readTree(jsonContent);
                return jsonContent;
            } catch (Exception e) {
                log.warn("提取的JSON格式无效: {}", e.getMessage());
            }
        }

        // 如果没有找到完整JSON，返回默认JSON
        log.warn("无法从响应中提取有效JSON，原始内容: {}", content);
        return createDefaultJsonResponse();
    }

    /**
     * 创建默认响应
     */
    private QwenRecognitionDTO createDefaultResponse() {
        return new QwenRecognitionDTO()
                .setScientificName("未识别")
                .setCommonName("Unknown")
                .setChineseName("未知海洋生物")
                .setDescription("图片识别失败，请重新上传清晰的海洋生物图片")
                .setConfidence(0.0);
    }

    /**
     * 创建默认JSON响应
     */
    private String createDefaultJsonResponse() {
        return """
        {
            "scientificName": "未识别",
            "commonName": "Unknown",
            "chineseName": "未知海洋生物",
            "classification": {
                "kingdom": "未确定",
                "phylum": "未确定",
                "clazz": "未确定",
                "order": "未确定",
                "family": "未确定",
                "genus": "未确定",
                "species": "未确定"
            },
            "habitat": "未确定",
            "distribution": "未确定",
            "characteristics": "未确定",
            "sizeRange": "未确定",
            "diet": "未确定",
            "conservationStatus": "未确定",
            "description": "图片识别失败，请重新上传清晰的海洋生物图片",
            "confidence": 0.0
        }
        """;
    }


}
~~~

核心配置属性

java

```java
@Value("${qwen.api.key}")
private String apiKey;           // API密钥

@Value("${qwen.api.endpoint}")
private String endpoint;         // API端点URL

@Value("${qwen.api.model}")
private String model;           // 使用的模型名称
```

核心方法详解

1. `recognizeMarineSpecies(MultipartFile imageFile)`

**作用**：主要的公共接口方法，负责识别海洋生物图片

**处理流程**：

- 将上传的图片文件转换为Base64编码
- 构建符合千问API格式的请求体
- 发送HTTP请求到千问API
- 解析响应并返回结构化的识别结果

**返回值**：`QwenRecognitionDTO` 对象，包含完整的生物信息

2. `buildCorrectRequestBody(String base64Image)`

**作用**：构建符合千问多模态API标准的请求体

**请求体结构**：

json

```json
{
  "model": "qwen-vl-plus",
  "input": {
    "messages": [
      {
        "role": "user",
        "content": [
          {
            "text": "识别提示词"
          },
          {
            "image": "data:image/jpeg;base64,图片数据"
          }
        ]
      }
    ]
  },
  "parameters": {
    "max_tokens": 2000,
    "temperature": 0.1,
    "top_p": 0.8
  }
}
```

**关键特点**：

- 支持多模态输入（文本+图片）
- 设置合理的生成参数
- 遵循千问API的标准格式

3. `buildPrompt()`

**作用**：构建专门用于海洋生物识别的提示词

**提示词特点**：

- 明确要求返回JSON格式
- 定义了详细的生物分类信息结构
- 包含学名、俗名、分类、栖息地等完整信息
- 设置了置信度评估机制

**要求的JSON结构**：

json

```json
{
  "scientificName": "学名",
  "commonName": "英文俗名",
  "chineseName": "中文名",
  "classification": {
    "kingdom": "界",
    "phylum": "门",
    "clazz": "纲",
    "order": "目",
    "family": "科",
    "genus": "属",
    "species": "种"
  },
  "habitat": "栖息地描述",
  "distribution": "分布区域",
  "characteristics": "特征描述",
  "sizeRange": "体型范围",
  "diet": "食性",
  "conservationStatus": "保护状态",
  "description": "详细描述",
  "confidence": 0.95
}
```

4. `sendRequest(Map<String, Object> requestBody)`

**作用**：发送HTTP POST请求到千问API

**实现细节**：

- 使用Apache HttpClient发送请求
- 设置正确的请求头（Authorization、Content-Type）
- 实现完整的请求/响应处理
- 提供详细的日志记录
- 包含错误状态码处理

**安全特性**：

- 避免在日志中记录完整的图片数据
- 只记录请求体大小和基本结构信息

5. `parseResponse(String response)`

**作用**：解析千问API的响应并提取识别结果

**解析策略**：

1. **DashScope格式**：`output.choices[0].message.content[0].text`
2. **OpenAI格式**：`choices[0].message.content`（备用兼容）
3. **其他格式**：`result.response`（旧版接口兼容）

**处理流程**：

- 多层级尝试解析响应结构
- 提取JSON内容
- 转换为DTO对象
- 异常时返回默认响应

6. `extractJsonFromContent(String content)`

**作用**：从响应内容中提取有效的JSON数据

**处理能力**：

- 移除markdown代码块标记
- 定位JSON的开始和结束位置
- 验证JSON格式的有效性
- 提供降级处理机制

7. 默认响应方法

**`createDefaultResponse()`** 和 **`createDefaultJsonResponse()`**

**作用**：当识别失败时提供默认的响应数据

**默认内容**：

- 所有字段标记为"未识别"或"未确定"
- 置信度设为0.0
- 提供友好的错误描述

8. `testRecognition(String base64Image)`

**作用**：提供测试接口，用于调试和验证识别功能

**特点**：

- 简化的测试方法
- 详细的日志输出
- 异常信息包装

技术特点

1. **多模态AI集成**

- 支持图片+文本的组合输入
- 专门针对视觉识别任务优化

2. **健壮的异常处理**

- 多层级的错误处理机制
- 提供默认响应避免系统崩溃
- 详细的日志记录便于调试

3. **灵活的响应解析**

- 支持多种API响应格式
- 兼容不同版本的千问API
- 智能JSON提取和验证

4. **专业的领域适配**

- 专门针对海洋生物识别场景
- 提供完整的生物分类信息结构
- 支持中英文双语识别结果

5. **性能优化**

- 使用连接池管理HTTP连接
- 避免敏感数据的过度日志记录
- 合理的API参数设置

使用场景

1. **海洋生物科研**：为科研人员提供快速的物种识别
2. **教育应用**：帮助学生学习海洋生物知识
3. **生态监测**：支持海洋生态环境监测项目
4. **科普应用**：为公众提供海洋生物识别服务

扩展性

该服务类设计良好，具有以下扩展性：

- 可以轻松修改提示词以适应其他识别需求
- 支持不同的AI模型切换
- 可以扩展支持其他类型的生物识别
- 便于集成到更大的生物识别系统中



## 8. MarineSpeciesService

### 类概述

`MarineSpeciesService`是一个Spring Boot服务类，专门用于处理海洋生物相关的业务逻辑。该类继承了MyBatis-Plus的`ServiceImpl`基类，提供了完整的CRUD操作能力，并集成了AI图像识别功能来自动识别和保存海洋生物信息。

### 主要作用

1. **智能识别**：通过上传图片自动识别海洋生物种类
2. **数据管理**：提供海洋生物信息的增删改查操作
3. **文件处理**：处理图片文件的上传、存储和删除
4. **数据转换**：将AI识别结果转换为数据库实体
5. **业务封装**：封装复杂的业务逻辑，提供简洁的API接口

### 完整代码

~~~ java
package com.marine.service;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.marine.dto.QwenRecognitionDTO;
import com.marine.entity.MarineSpecies;
import com.marine.mapper.MarineSpeciesMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

/**
 * 海洋生物业务逻辑服务
 */
@Service
@Slf4j
@RequiredArgsConstructor
public class MarineSpeciesService extends ServiceImpl<MarineSpeciesMapper, MarineSpecies> {

    private final QwenVisionService qwenVisionService;
    private final ObjectMapper objectMapper = new ObjectMapper();

    // 图片存储路径
    private static final String IMAGE_UPLOAD_PATH = "uploads/images/";

    /**
     * 通过图片识别并保存海洋生物信息
     */
    @Transactional
    public MarineSpecies recognizeAndSave(MultipartFile imageFile) throws IOException {
        // 1. 验证文件
        validateImageFile(imageFile);

        // 2. 保存图片文件
        String imagePath = saveImageFile(imageFile);

        try {
            // 3. 调用千问API识别
            QwenRecognitionDTO recognition = qwenVisionService.recognizeMarineSpecies(imageFile);
            log.info("识别结果: {}", recognition);

            // 4. 转换为实体对象
            MarineSpecies marineSpecies = convertToEntity(recognition, imagePath);

            // 5. 保存到数据库
            save(marineSpecies);

            log.info("成功保存海洋生物信息: {}", marineSpecies.getId());
            return marineSpecies;

        } catch (Exception e) {
            // 识别失败时删除已保存的图片
            deleteImageFile(imagePath);
            throw new RuntimeException("识别并保存海洋生物信息失败: " + e.getMessage(), e);
        }
    }

    /**
     * 分页查询海洋生物
     */
    public Page<MarineSpecies> getSpeciesPage(int pageNum, int pageSize, String keyword) {
        Page<MarineSpecies> page = new Page<>(pageNum, pageSize);
        QueryWrapper<MarineSpecies> wrapper = new QueryWrapper<>();

        if (keyword != null && !keyword.trim().isEmpty()) {
            wrapper.and(w -> w
                    .like("scientific_name", keyword)
                    .or()
                    .like("common_name", keyword)
                    .or()
                    .like("chinese_name", keyword)
            );
        }

        wrapper.orderByDesc("created_time");
        return page(page, wrapper);
    }

    /**
     * 根据学名查询是否已存在
     */
    public boolean existsByScientificName(String scientificName) {
        QueryWrapper<MarineSpecies> wrapper = new QueryWrapper<>();
        wrapper.eq("scientific_name", scientificName);
        return count(wrapper) > 0;
    }

    /**
     * 验证图片文件
     */
    private void validateImageFile(MultipartFile file) {
        if (file.isEmpty()) {
            throw new IllegalArgumentException("请选择要上传的图片");
        }
        // 检查文件大小 (10MB)
        if (file.getSize() > 10 * 1024 * 1024) {
            throw new IllegalArgumentException("图片文件大小不能超过10MB");
        }

        // 检查文件类型
        String contentType = file.getContentType();
        List<String> allowedTypes = Arrays.asList("image/jpeg", "image/jpg", "image/png", "image/gif");
        if (contentType == null || !allowedTypes.contains(contentType.toLowerCase())) {
            throw new IllegalArgumentException("只支持JPG、PNG、GIF格式的图片");
        }
    }

    /**
     * 保存图片文件
     */
    private String saveImageFile(MultipartFile file) throws IOException {
        // 创建上传目录
        File uploadDir = new File(IMAGE_UPLOAD_PATH);
        if (!uploadDir.exists()) {
            uploadDir.mkdirs();
        }

        // 生成唯一文件名
        String originalFilename = file.getOriginalFilename();
        String fileExtension = originalFilename.substring(originalFilename.lastIndexOf("."));
        String fileName = UUID.randomUUID().toString() + fileExtension;
        String filePath = IMAGE_UPLOAD_PATH + fileName;
        System.out.println("filePath="+filePath);
        // 保存文件
        Path path = Paths.get(filePath);
        Files.write(path, file.getBytes());

        log.info("图片保存成功: {}", filePath);
        return filePath;
    }

    /**
     * 删除图片文件
     */
    private void deleteImageFile(String imagePath) {
        try {
            Files.deleteIfExists(Paths.get(imagePath));
            log.info("删除图片文件: {}", imagePath);
        } catch (IOException e) {
            log.error("删除图片文件失败: {}", imagePath, e);
        }
    }

    /**
     * 转换识别结果为实体对象
     */
    private MarineSpecies convertToEntity(QwenRecognitionDTO recognition, String imagePath) {
        try {
            MarineSpecies species = new MarineSpecies();
            species.setScientificName(recognition.getScientificName());
            species.setCommonName(recognition.getCommonName());
            species.setChineseName(recognition.getChineseName());
            species.setHabitat(recognition.getHabitat());
            species.setDistribution(recognition.getDistribution());
            species.setCharacteristics(recognition.getCharacteristics());
            species.setSizeRange(recognition.getSizeRange());
            species.setDiet(recognition.getDiet());
            species.setConservationStatus(recognition.getConservationStatus());
            species.setDescription(recognition.getDescription());
            species.setCreatedTime(LocalDateTime.now());
            species.setUpdatedTime(LocalDateTime.now());
            species.setIsDeleted(0);

            // 转换分类信息为JSON
            if (recognition.getClassification() != null) {
                String classificationJson = objectMapper.writeValueAsString(recognition.getClassification());
                species.setClassification(classificationJson);
            }

            // 设置图片URL
            species.setImageUrls(objectMapper.writeValueAsString(Arrays.asList(imagePath)));

            return species;
        } catch (Exception e) {
            throw new RuntimeException("转换识别结果失败", e);
        }
    }

    /**
     * 获取所有物种列表
     */
    public List<MarineSpecies> getAllSpecies() {
        QueryWrapper<MarineSpecies> wrapper = new QueryWrapper<>();
        wrapper.orderByDesc("created_time");
        return list(wrapper);
    }

    /**
     * 根据ID获取详细信息
     */
    public MarineSpecies getSpeciesDetail(Long id) {
        return getById(id);
    }

    /**
     * 删除物种信息
     */
    @Transactional
    public boolean deleteSpecies(Long id) {
        MarineSpecies species = getById(id);
        if (species != null) {
            // 删除关联的图片文件
            try {
                if (species.getImageUrls() != null) {
                    String[] imageUrls = objectMapper.readValue(species.getImageUrls(), String[].class);
                    for (String imageUrl : imageUrls) {
                        deleteImageFile(imageUrl);
                    }
                }
            } catch (Exception e) {
                log.error("删除图片文件失败", e);
            }

            return removeById(id);
        }
        return false;
    }
}
~~~

核心方法详细解释

1. `recognizeAndSave(MultipartFile imageFile)`

**作用**：这是核心业务方法，实现了图片上传→AI识别→数据保存的完整流程

**执行步骤**：

- 验证上传的图片文件（大小、格式等）
- 将图片保存到服务器指定目录
- 调用千问视觉API进行海洋生物识别
- 将识别结果转换为数据库实体对象
- 保存到数据库并返回结果
- 异常处理：识别失败时自动删除已保存的图片

2. `getSpeciesPage(int pageNum, int pageSize, String keyword)`

**作用**：分页查询海洋生物信息，支持关键词搜索

**特点**：

- 支持按学名、俗名、中文名进行模糊搜索
- 按创建时间倒序排列
- 返回分页结果，便于前端展示

3. `validateImageFile(MultipartFile file)`

**作用**：验证上传的图片文件是否符合要求

**验证项目**：

- 文件是否为空
- 文件大小限制（最大10MB）
- 文件格式限制（支持JPG、PNG、GIF）

4. `saveImageFile(MultipartFile file)`

**作用**：将上传的图片保存到服务器本地

**处理逻辑**：

- 创建上传目录（如不存在）
- 生成UUID唯一文件名避免冲突
- 保留原始文件扩展名
- 使用NIO方式写入文件

5. `convertToEntity(QwenRecognitionDTO recognition, String imagePath)`

**作用**：将AI识别结果转换为数据库实体对象

**转换内容**：

- 基本信息：学名、俗名、中文名等
- 生物特征：栖息地、分布、特征描述等
- 分类信息：转换为JSON格式存储
- 图片路径：转换为JSON数组格式
- 时间戳：设置创建和更新时间

6. `deleteSpecies(Long id)`

**作用**：删除海洋生物信息及关联的图片文件

**处理逻辑**：

- 查询要删除的物种信息
- 解析图片URL数组
- 删除服务器上的图片文件
- 删除数据库记录

7. `existsByScientificName(String scientificName)`

**作用**：检查指定学名的海洋生物是否已存在

**用途**：防止重复录入相同物种

技术特点

1. **事务管理**：关键操作使用`@Transactional`确保数据一致性
2. **异常处理**：完善的异常处理机制，失败时自动清理资源
3. **日志记录**：使用Slf4j记录关键操作和异常信息
4. **JSON处理**：使用Jackson处理复杂数据结构的序列化
5. **文件管理**：完整的文件上传、存储、删除机制
6. **数据验证**：严格的文件格式和大小验证

依赖服务

- **QwenVisionService**：千问视觉识别服务，负责图片识别
- **MarineSpeciesMapper**：MyBatis数据访问层
- **ObjectMapper**：JSON序列化工具

这个服务类设计完善，既考虑了业务功能的完整性，也注重了异常处理和资源管理，是一个典型的企业级Spring Boot服务实现。

## 9. MarineSpeciesController

### 概述

MarineSpeciesController 是一个基于Spring Boot框架的Web控制器，专门用于海洋生物识别系统。该控制器采用了前后端分离的设计思想，同时提供传统的MVC页面渲染和RESTful API接口，以满足不同客户端的访问需求。

### 技术架构特点

- **框架依赖**: 基于Spring Boot + MyBatis Plus
- **设计模式**: 采用依赖注入(DI)和控制反转(IoC)
- **响应方式**: 支持页面跳转和JSON API响应
- **日志记录**: 集成SLF4J进行操作日志记录
- **分页支持**: 集成MyBatis Plus分页插件

### 主要作用

1. **图像识别处理**: 接收用户上传的海洋生物图片，调用识别服务进行物种识别
2. **数据管理**: 提供海洋生物物种的CRUD操作接口
3. **页面展示**: 渲染Web页面，展示识别结果和物种信息
4. **API服务**: 为前端应用或第三方系统提供RESTful API接口

~~~ java
package com.marine.controller;


import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.marine.entity.MarineSpecies;
import com.marine.service.MarineSpeciesService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 海洋生物识别控制器
 */
@Controller
@RequestMapping("/marine")
@RequiredArgsConstructor
@Slf4j
public class MarineSpeciesController {

    private final MarineSpeciesService marineSpeciesService;

    /**
     * 首页 - 显示上传页面
     */
    @GetMapping({"", "/", "/index"})
    public String index() {
        return "index";
    }

    /**
     * 上传图片识别
     */
    @PostMapping("/upload")
    public String uploadImage(@RequestParam("imageFile") MultipartFile imageFile,
                              RedirectAttributes redirectAttributes) {
        try {
            if (imageFile.isEmpty()) {
                redirectAttributes.addFlashAttribute("error", "请选择要上传的图片");
                return "redirect:/marine/index";
            }

            log.info("开始处理图片上传: {}", imageFile.getOriginalFilename());

            // 识别并保存
            MarineSpecies result = marineSpeciesService.recognizeAndSave(imageFile);

            redirectAttributes.addFlashAttribute("success", "图片识别成功！");
            redirectAttributes.addFlashAttribute("speciesId", result.getId());

            return "redirect:/marine/detail/" + result.getId();

        } catch (Exception e) {
            log.error("图片识别失败", e);
            redirectAttributes.addFlashAttribute("error", "识别失败: " + e.getMessage());
            return "redirect:/marine/index";
        }
    }

    /**
     * AJAX上传接口
     */
    @PostMapping("/api/upload")
    @ResponseBody
    public ResponseEntity<Map<String, Object>> uploadImageAjax(@RequestParam("imageFile") MultipartFile imageFile) {
        Map<String, Object> result = new HashMap<>();

        try {
            if (imageFile.isEmpty()) {
                result.put("success", false);
                result.put("message", "请选择要上传的图片");
                return ResponseEntity.badRequest().body(result);
            }

            log.info("AJAX处理图片上传: {}", imageFile.getOriginalFilename());

            // 识别并保存
            MarineSpecies species = marineSpeciesService.recognizeAndSave(imageFile);

            result.put("success", true);
            result.put("message", "识别成功");
            result.put("data", species);

            return ResponseEntity.ok(result);

        } catch (Exception e) {
            log.error("AJAX图片识别失败", e);
            result.put("success", false);
            result.put("message", "识别失败: " + e.getMessage());
            return ResponseEntity.ok(result);
        }
    }

    /**
     * 物种详情页面
     */
    @GetMapping("/detail/{id}")
    public String speciesDetail(@PathVariable Long id, Model model) {
        try {
            MarineSpecies species = marineSpeciesService.getSpeciesDetail(id);
            if (species == null) {
                model.addAttribute("error", "未找到该物种信息");
                return "error";
            }

            model.addAttribute("species", species);
            return "detail";

        } catch (Exception e) {
            log.error("获取物种详情失败", e);
            model.addAttribute("error", "获取详情失败: " + e.getMessage());
            return "error";
        }
    }

    /**
     * 物种列表页面
     */
    @GetMapping("/list")
    public String speciesList(@RequestParam(defaultValue = "1") int page,
                              @RequestParam(defaultValue = "10") int size,
                              @RequestParam(required = false) String keyword,
                              Model model) {
        try {
            Page<MarineSpecies> speciesPage = marineSpeciesService.getSpeciesPage(page, size, keyword);

            model.addAttribute("speciesPage", speciesPage);
            model.addAttribute("keyword", keyword);
            model.addAttribute("currentPage", page);
            model.addAttribute("pageSize", size);

            return "list";

        } catch (Exception e) {
            log.error("获取物种列表失败", e);
            model.addAttribute("error", "获取列表失败: " + e.getMessage());
            return "error";
        }
    }

    /**
     * API - 获取物种列表
     */
    @GetMapping("/api/list")
    @ResponseBody
    public ResponseEntity<Map<String, Object>> getSpeciesListApi(
            @RequestParam(defaultValue = "1") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(required = false) String keyword) {

        Map<String, Object> result = new HashMap<>();

        try {
            Page<MarineSpecies> speciesPage = marineSpeciesService.getSpeciesPage(page, size, keyword);

            result.put("success", true);
            result.put("data", speciesPage);

            return ResponseEntity.ok(result);

        } catch (Exception e) {
            log.error("API获取物种列表失败", e);
            result.put("success", false);
            result.put("message", "获取列表失败: " + e.getMessage());
            return ResponseEntity.ok(result);
        }
    }

    /**
     * API - 获取物种详情
     */
    @GetMapping("/api/detail/{id}")
    @ResponseBody
    public ResponseEntity<Map<String, Object>> getSpeciesDetailApi(@PathVariable Long id) {
        Map<String, Object> result = new HashMap<>();

        try {
            MarineSpecies species = marineSpeciesService.getSpeciesDetail(id);

            if (species == null) {
                result.put("success", false);
                result.put("message", "未找到该物种信息");
                return ResponseEntity.ok(result);
            }

            result.put("success", true);
            result.put("data", species);

            return ResponseEntity.ok(result);

        } catch (Exception e) {
            log.error("API获取物种详情失败", e);
            result.put("success", false);
            result.put("message", "获取详情失败: " + e.getMessage());
            return ResponseEntity.ok(result);
        }
    }

    /**
     * 删除物种
     */
    @PostMapping("/delete/{id}")
    @ResponseBody
    public ResponseEntity<Map<String, Object>> deleteSpecies(@PathVariable Long id) {
        Map<String, Object> result = new HashMap<>();

        try {
            boolean success = marineSpeciesService.deleteSpecies(id);

            if (success) {
                result.put("success", true);
                result.put("message", "删除成功");
            } else {
                result.put("success", false);
                result.put("message", "删除失败，未找到该记录");
            }

            return ResponseEntity.ok(result);

        } catch (Exception e) {
            log.error("删除物种失败", e);
            result.put("success", false);
            result.put("message", "删除失败: " + e.getMessage());
            return ResponseEntity.ok(result);
        }
    }

    /**
     * 获取所有物种（用于下拉选择等）
     */
    @GetMapping("/api/all")
    @ResponseBody
    public ResponseEntity<Map<String, Object>> getAllSpecies() {
        Map<String, Object> result = new HashMap<>();

        try {
            List<MarineSpecies> speciesList = marineSpeciesService.getAllSpecies();

            result.put("success", true);
            result.put("data", speciesList);

            return ResponseEntity.ok(result);

        } catch (Exception e) {
            log.error("获取所有物种失败", e);
            result.put("success", false);
            result.put("message", "获取数据失败: " + e.getMessage());
            return ResponseEntity.ok(result);
        }
    }

    /**
     * 批量上传页面
     */
    @GetMapping("/batch")
    public String batchUpload() {
        return "batch";
    }

    /**
     * 统计信息API
     */
    @GetMapping("/api/statistics")
    @ResponseBody
    public ResponseEntity<Map<String, Object>> getStatistics() {
        Map<String, Object> result = new HashMap<>();

        try {
            long totalCount = marineSpeciesService.count();

            Map<String, Object> statistics = new HashMap<>();
            statistics.put("totalSpecies", totalCount);

            result.put("success", true);
            result.put("data", statistics);

            return ResponseEntity.ok(result);

        } catch (Exception e) {
            log.error("获取统计信息失败", e);
            result.put("success", false);
            result.put("message", "获取统计信息失败: " + e.getMessage());
            return ResponseEntity.ok(result);
        }
    }
}
~~~

### 核心方法详细解释

#### 1. 页面渲染方法

`index()` - 首页入口

java

```java
@GetMapping({"", "/", "/index"})
public String index()
```

- **作用**: 显示图片上传页面
- **支持路径**: 根路径、/、/index
- **返回**: index.html模板页面

#### 2. 图片上传识别方法

`uploadImage()` - 传统表单上传



java

```java
@PostMapping("/upload")
public String uploadImage(@RequestParam("imageFile") MultipartFile imageFile, RedirectAttributes redirectAttributes)
```

- **功能**: 处理表单提交的图片文件

- 核心流程

  :

  1. 验证文件是否为空
  2. 记录上传日志
  3. 调用识别服务进行图片识别和数据保存
  4. 设置重定向属性传递结果信息
  5. 跳转到详情页面或返回错误页面

- **异常处理**: 捕获所有异常并记录日志，友好提示用户

`uploadImageAjax()` - AJAX异步上传



java

```java
@PostMapping("/api/upload")
@ResponseBody
public ResponseEntity<Map<String, Object>> uploadImageAjax(@RequestParam("imageFile") MultipartFile imageFile)
```

- **功能**: 提供异步图片上传API接口
- **响应格式**: JSON格式，包含success状态、message信息和data数据
- **优势**: 支持前端异步调用，用户体验更好

#### 3. 数据查询方法

`speciesDetail()` - 物种详情页面



java

```java
@GetMapping("/detail/{id}")
public String speciesDetail(@PathVariable Long id, Model model)
```

- **功能**: 展示特定物种的详细信息页面
- **参数**: 路径变量id指定物种ID
- **模型数据**: 将物种信息添加到Model中供模板使用

`speciesList()` - 物种列表页面



java

```java
@GetMapping("/list")
public String speciesList(@RequestParam(defaultValue = "1") int page, @RequestParam(defaultValue = "10") int size, @RequestParam(required = false) String keyword, Model model)
```

- **功能**: 展示物种列表，支持分页和关键词搜索
- 分页参数:
  - page: 当前页码（默认1）
  - size: 每页大小（默认10）
  - keyword: 搜索关键词（可选）

#### 4. API接口方法

`getSpeciesListApi()` - 物种列表API



java

```java
@GetMapping("/api/list")
@ResponseBody
public ResponseEntity<Map<String, Object>> getSpeciesListApi(...)
```

- **功能**: 提供物种列表的JSON API接口
- **支持功能**: 分页查询、关键词搜索
- **返回格式**: 标准化的JSON响应结构

`getSpeciesDetailApi()` - 物种详情API



java

```java
@GetMapping("/api/detail/{id}")
@ResponseBody
public ResponseEntity<Map<String, Object>> getSpeciesDetailApi(@PathVariable Long id)
```

- **功能**: 获取特定物种详情的API接口
- **路径参数**: id为物种唯一标识

#### 5. 数据操作方法

`deleteSpecies()` - 删除物种



java

```java
@PostMapping("/delete/{id}")
@ResponseBody
public ResponseEntity<Map<String, Object>> deleteSpecies(@PathVariable Long id)
```

- **功能**: 删除指定的物种记录
- **安全性**: 通过POST请求执行删除操作
- **返回**: JSON格式的操作结果

`getAllSpecies()` - 获取所有物种



java

```java
@GetMapping("/api/all")
@ResponseBody
public ResponseEntity<Map<String, Object>> getAllSpecies()
```

- **功能**: 获取系统中所有物种数据
- **用途**: 主要用于下拉选择框等UI组件的数据源

#### 6. 辅助功能方法

`batchUpload()` - 批量上传页面



java

```java
@GetMapping("/batch")
public String batchUpload()
```

- **功能**: 显示批量上传功能页面
- **扩展性**: 为未来批量处理功能预留接口

`getStatistics()` - 统计信息API



java

```java
@GetMapping("/api/statistics")
@ResponseBody
public ResponseEntity<Map<String, Object>> getStatistics()
```

- **功能**: 提供系统统计信息
- **当前统计**: 物种总数量
- **扩展性**: 可添加更多统计维度

设计亮点

1. 双重响应模式

- **页面模式**: 传统MVC模式，适合SEO和初始页面加载
- **API模式**: RESTful接口，支持前端异步调用和移动端接入

2. 统一异常处理

- 所有方法都包含try-catch异常处理
- 详细的错误日志记录
- 用户友好的错误信息反馈

3. 标准化响应格式

API接口采用统一的响应格式：

json

```json
{
  "success": true/false,
  "message": "操作结果信息",
  "data": "具体数据内容"
}
```

4. 灵活的参数处理

- 支持可选参数和默认值设置
- 合理的参数验证和错误处理
- 支持多种HTTP方法和路径匹配

应用场景

1. **科研教育**: 海洋生物学研究和教学辅助
2. **环保监测**: 海洋生态环境监测和物种统计
3. **科普应用**: 公众海洋生物知识普及平台
4. **移动应用**: 为移动端APP提供后端API支持

这个控制器展现了现代Web应用开发的最佳实践，兼顾了功能完整性、用户体验和系统可扩展性。

## 10. application.yml

![image-20250623152206643](assets/image-20250623152206643.png)

~~~ yaml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/ocean_db?useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai&useSSL=false
    username: root
    password: 1111
    # Druid 数据源配置
    druid:
      initial-size: 5  # 初始化连接数
      min-idle: 5      # 最小空闲连接数
      max-active: 20   # 最大连接数
      max-wait: 60000  # 获取连接时最大等待时间
      validation-query: SELECT 1 FROM DUAL  # 校验连接的SQL
  servlet:
    multipart:
      max-file-size: 2MB        # 单个文件最大大小
      max-request-size: 10MB    # 整个请求最大大小
      enabled: true
mybatis-plus:
  # 不支持多包, 如有需要可在注解配置 或 提升扫包等级
  # 例如 com.**.**.mapper
  mapperPackage: com.marine.mapper
  # 对应的 XML 文件位置
  mapperLocations: classpath*:mapper/**/*Mapper.xml
  # 实体扫描，多个package用逗号或者分号分隔
  typeAliasesPackage: com.marine.entity
  # 启动时是否检查 MyBatis XML 文件的存在，默认不检查
  checkConfigLocation: false
  configuration:
    # 自动驼峰命名规则（camel case）映射   数据库表的字段user_name---->实体类的userName
    mapUnderscoreToCamelCase: true
    # MyBatis 自动映射策略
    # NONE：不启用 PARTIAL：只对非嵌套 resultMap 自动映射 FULL：对所有 resultMap 自动映射
    autoMappingBehavior: FULL
    # MyBatis 自动映射时未知列或未知属性处理策
    # NONE：不做处理 WARNING：打印相关警告 FAILING：抛出异常和详细信息
    autoMappingUnknownColumnBehavior: NONE
    # 更详细的日志输出 会有性能损耗 org.apache.ibatis.logging.stdout.StdOutImpl
    # 默认日志输出 org.apache.ibatis.logging.slf4j.Slf4jImpl
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
server:
  port: 8080
# 阿里千问API配置
qwen:
  api:
    key: sk-6006411787c44403a00bc0135119a547
    endpoint: https://dashscope.aliyuncs.com/api/v1/services/aigc/multimodal-generation/generation
    model: qwen-vl-plus
# 日志配置
logging:
  level:
    com.marine: debug
    org.springframework.web: debug

~~~





## 11. index.html页面视图

- /resources/templates/index.html

这是一个海洋生物识别系统的前端上传页面，主要用于用户上传海洋生物图片并进行AI识别。我来详细解释这个页面的概述、作用和核心代码。

页面概述

这是一个现代化的单页面应用，采用渐变背景和毛玻璃效果设计，为用户提供直观友好的海洋生物图片上传和识别界面。页面使用Thymeleaf模板引擎，支持服务端渲染。

主要作用

1. **图片上传**：支持点击选择或拖拽上传海洋生物图片
2. **实时预览**：上传前可预览选中的图片
3. **AI识别**：调用后端API进行海洋生物智能识别
4. **用户反馈**：提供加载动画、进度条和结果提示
5. **导航功能**：提供查看历史记录和批量上传的入口

~~~ html
<!DOCTYPE html>
<html lang="zh-CN" xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>海洋生物识别系统</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 40px;
      box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(10px);
      max-width: 600px;
      width: 100%;
      text-align: center;
    }

    h1 {
      color: #333;
      font-size: 2.5rem;
      margin-bottom: 10px;
      font-weight: 600;
    }

    .subtitle {
      color: #666;
      font-size: 1.1rem;
      margin-bottom: 30px;
    }

    .upload-area {
      border: 3px dashed #4f46e5;
      border-radius: 15px;
      padding: 40px 20px;
      margin: 30px 0;
      cursor: pointer;
      transition: all 0.3s ease;
      background: linear-gradient(135deg, #f8fafc 0%, #e0e7ff 100%);
      position: relative;
      overflow: hidden;
    }

    .upload-area:hover {
      border-color: #3730a3;
      background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%);
      transform: translateY(-2px);
    }

    .upload-area.dragover {
      border-color: #1e40af;
      background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
      transform: scale(1.02);
    }

    .upload-icon {
      font-size: 3rem;
      color: #4f46e5;
      margin-bottom: 15px;
    }

    .upload-text {
      color: #4b5563;
      font-size: 1.1rem;
      margin-bottom: 10px;
    }

    .upload-hint {
      color: #9ca3af;
      font-size: 0.9rem;
    }

    .file-input {
      display: none;
    }

    .preview-area {
      margin: 20px 0;
      display: none;
    }

    .preview-image {
      max-width: 100%;
      max-height: 300px;
      border-radius: 10px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }

    .upload-btn {
      background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 25px;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      margin: 20px 10px;
      font-weight: 500;
    }

    .upload-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(79, 70, 229, 0.4);
    }

    .upload-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .nav-btn {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      text-decoration: none;
      padding: 10px 20px;
      border-radius: 20px;
      margin: 10px;
      display: inline-block;
      transition: all 0.3s ease;
    }

    .nav-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
      text-decoration: none;
      color: white;
    }

    .loading {
      display: none;
      margin: 20px 0;
    }

    .spinner {
      border: 4px solid #f3f4f6;
      border-top: 4px solid #4f46e5;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .alert {
      padding: 15px 20px;
      border-radius: 10px;
      margin: 20px 0;
      font-weight: 500;
    }

    .alert-success {
      background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
      color: #065f46;
      border-left: 4px solid #10b981;
    }

    .alert-error {
      background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
      color: #991b1b;
      border-left: 4px solid #ef4444;
    }

    .progress-bar {
      width: 100%;
      height: 4px;
      background: #e5e7eb;
      border-radius: 2px;
      overflow: hidden;
      margin: 20px 0;
      display: none;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4f46e5, #7c3aed);
      width: 0%;
      transition: width 0.3s ease;
    }

    @media (max-width: 768px) {
      .container {
        padding: 20px;
        margin: 10px;
      }

      h1 {
        font-size: 2rem;
      }

      .upload-area {
        padding: 30px 15px;
      }
    }
  </style>
</head>
<body>
<div class="container">
  <h1>🐠 海洋生物识别系统</h1>
  <p class="subtitle">上传海洋生物图片，AI智能识别物种信息</p>

  <!-- 成功提示 -->
  <div th:if="${success}" class="alert alert-success">
    <span th:text="${success}"></span>
  </div>

  <!-- 错误提示 -->
  <div th:if="${error}" class="alert alert-error">
    <span th:text="${error}"></span>
  </div>

  <!-- 上传表单 -->
  <form id="uploadForm" th:action="@{/marine/upload}" method="post" enctype="multipart/form-data">
    <div class="upload-area" id="uploadArea">
      <div class="upload-icon">📸</div>
      <div class="upload-text">点击选择图片或拖拽图片到此处</div>
      <div class="upload-hint">支持 JPG、PNG、GIF 格式，最大 10MB</div>
      <input type="file" id="imageFile" name="imageFile" class="file-input" accept="image/*">
    </div>

    <!-- 图片预览 -->
    <div class="preview-area" id="previewArea">
      <img id="previewImage" class="preview-image" alt="预览图片">
    </div>

    <!-- 进度条 -->
    <div class="progress-bar" id="progressBar">
      <div class="progress-fill" id="progressFill"></div>
    </div>

    <!-- 加载状态 -->
    <div class="loading" id="loading">
      <div class="spinner"></div>
      <p>AI正在识别中，请稍候...</p>
    </div>

    <!-- 按钮 -->
    <button type="submit" class="upload-btn" id="uploadBtn" disabled>
      🚀 开始识别
    </button>
  </form>

  <!-- 导航按钮 -->
  <div style="margin-top: 30px;">
    <a href="/marine/list" class="nav-btn">📋 查看识别记录</a>
    <a href="/marine/batch" class="nav-btn">📦 批量上传</a>
  </div>
</div>

<script>
  // DOM 元素
  const uploadArea = document.getElementById('uploadArea');
  const fileInput = document.getElementById('imageFile');
  const previewArea = document.getElementById('previewArea');
  const previewImage = document.getElementById('previewImage');
  const uploadBtn = document.getElementById('uploadBtn');
  const loading = document.getElementById('loading');
  const progressBar = document.getElementById('progressBar');
  const progressFill = document.getElementById('progressFill');
  const uploadForm = document.getElementById('uploadForm');

  // 点击上传区域
  uploadArea.addEventListener('click', () => {
    fileInput.click();
  });

  // 文件选择
  fileInput.addEventListener('change', handleFileSelect);

  // 拖拽功能
  uploadArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    uploadArea.classList.add('dragover');
  });

  uploadArea.addEventListener('dragleave', () => {
    uploadArea.classList.remove('dragover');
  });

  uploadArea.addEventListener('drop', (e) => {
    e.preventDefault();
    uploadArea.classList.remove('dragover');

    const files = e.dataTransfer.files;
    if (files.length > 0) {
      fileInput.files = files;
      handleFileSelect();
    }
  });

  // 处理文件选择
  function handleFileSelect() {
    const file = fileInput.files[0];

    if (!file) {
      uploadBtn.disabled = true;
      previewArea.style.display = 'none';
      return;
    }

    // 验证文件类型
    if (!file.type.startsWith('image/')) {
      alert('请选择图片文件！');
      return;
    }

    // 验证文件大小
    if (file.size > 10 * 1024 * 1024) {
      alert('图片文件大小不能超过10MB！');
      return;
    }

    // 显示预览
    const reader = new FileReader();
    reader.onload = (e) => {
      previewImage.src = e.target.result;
      previewArea.style.display = 'block';
      uploadBtn.disabled = false;
    };
    reader.readAsDataURL(file);
  }

  // 表单提交
  uploadForm.addEventListener('submit', (e) => {
    e.preventDefault();

    if (!fileInput.files[0]) {
      alert('请先选择图片！');
      return;
    }

    // 显示加载状态
    loading.style.display = 'block';
    progressBar.style.display = 'block';
    uploadBtn.disabled = true;

    // 模拟进度
    let progress = 0;
    const progressInterval = setInterval(() => {
      progress += Math.random() * 15;
      if (progress > 90) {
        progress = 90;
        clearInterval(progressInterval);
      }
      progressFill.style.width = progress + '%';
    }, 200);

    // 使用AJAX提交
    const formData = new FormData(uploadForm);

    fetch('/marine/api/upload', {
      method: 'POST',
      body: formData
    })
            .then(response => response.json())
            .then(data => {
              clearInterval(progressInterval);
              progressFill.style.width = '100%';

              setTimeout(() => {
                loading.style.display = 'none';
                progressBar.style.display = 'none';
                uploadBtn.disabled = false;

                if (data.success) {
                  // 成功跳转到详情页
                  window.location.href = '/marine/detail/' + data.data.id;
                } else {
                  alert('识别失败: ' + data.message);
                  progressFill.style.width = '0%';
                }
              }, 500);
            })
            .catch(error => {
              clearInterval(progressInterval);
              loading.style.display = 'none';
              progressBar.style.display = 'none';
              uploadBtn.disabled = false;
              progressFill.style.width = '0%';

              console.error('Error:', error);
              alert('网络错误，请重试！');
            });
  });

  // 页面加载完成后的动画
  window.addEventListener('load', () => {
    document.querySelector('.container').style.opacity = '0';
    document.querySelector('.container').style.transform = 'translateY(20px)';

    setTimeout(() => {
      document.querySelector('.container').style.transition = 'all 0.6s ease';
      document.querySelector('.container').style.opacity = '1';
      document.querySelector('.container').style.transform = 'translateY(0)';
    }, 100);
  });
</script>
</body>
</html>
~~~

## 核心代码详细解释

### 1. 样式设计核心



css

```css
body {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  /* 创建紫蓝色渐变背景 */
}

.container {
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
  /* 毛玻璃效果，提供现代化视觉体验 */
}

.upload-area {
  border: 3px dashed #4f46e5;
  cursor: pointer;
  transition: all 0.3s ease;
  /* 虚线边框的上传区域，支持悬停效果 */
}
```

### 2. 文件处理核心逻辑



javascript

```javascript
function handleFileSelect() {
  const file = fileInput.files[0];
  
  // 文件验证
  if (!file.type.startsWith('image/')) {
    alert('请选择图片文件！');
    return;
  }
  
  // 大小限制检查
  if (file.size > 10 * 1024 * 1024) {
    alert('图片文件大小不能超过10MB！');
    return;
  }
  
  // 生成预览
  const reader = new FileReader();
  reader.onload = (e) => {
    previewImage.src = e.target.result;
    previewArea.style.display = 'block';
    uploadBtn.disabled = false;
  };
  reader.readAsDataURL(file);
}
```

**关键功能**：

- 验证文件类型必须为图片格式
- 限制文件大小不超过10MB
- 使用FileReader API生成base64预览

### 3. 拖拽上传实现



javascript

```javascript
uploadArea.addEventListener('dragover', (e) => {
  e.preventDefault();
  uploadArea.classList.add('dragover');
});

uploadArea.addEventListener('drop', (e) => {
  e.preventDefault();
  uploadArea.classList.remove('dragover');
  
  const files = e.dataTransfer.files;
  if (files.length > 0) {
    fileInput.files = files;
    handleFileSelect();
  }
});
```

**技术要点**：

- `preventDefault()`阻止浏览器默认行为
- 通过CSS类切换提供视觉反馈
- 将拖拽文件赋值给input元素

### 4. AJAX提交与进度显示



javascript

```javascript
uploadForm.addEventListener('submit', (e) => {
  e.preventDefault();
  
  // 显示加载状态
  loading.style.display = 'block';
  progressBar.style.display = 'block';
  
  // 模拟进度动画
  let progress = 0;
  const progressInterval = setInterval(() => {
    progress += Math.random() * 15;
    if (progress > 90) {
      progress = 90;
      clearInterval(progressInterval);
    }
    progressFill.style.width = progress + '%';
  }, 200);
  
  // AJAX提交
  fetch('/marine/api/upload', {
    method: 'POST',
    body: new FormData(uploadForm)
  })
  .then(response => response.json())
  .then(data => {
    // 处理响应结果
    if (data.success) {
      window.location.href = '/marine/detail/' + data.data.id;
    } else {
      alert('识别失败: ' + data.message);
    }
  });
});
```

**核心机制**：

- 阻止表单默认提交，使用AJAX异步提交
- 实现模拟进度条，提升用户体验
- 成功后跳转到详情页面，失败则显示错误信息

### 5. Thymeleaf模板集成



html

```html
<!-- 成功提示 -->
<div th:if="${success}" class="alert alert-success">
  <span th:text="${success}"></span>
</div>

<!-- 错误提示 -->
<div th:if="${error}" class="alert alert-error">
  <span th:text="${error}"></span>
</div>

<form th:action="@{/marine/upload}" method="post">
```

**模板功能**：

- 条件渲染成功/错误消息
- 动态生成表单提交地址
- 支持服务端数据绑定

技术特点

1. **响应式设计**：支持移动端适配
2. **用户体验优化**：加载动画、进度反馈、拖拽上传
3. **错误处理完善**：文件类型验证、大小限制、网络异常处理
4. **现代化UI**：渐变背景、毛玻璃效果、动画过渡
5. **前后端分离**：使用AJAX与后端API交互

这个页面是一个功能完整、用户体验良好的文件上传界面，特别适用于需要图片识别功能的应用场景。

## 11. detail.html

~~~ html
<!DOCTYPE html>
<html lang="zh-CN" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title th:text="${species != null ? species.chineseName + ' - 海洋物种详情' : '海洋物种详情'}">海洋物种详情</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .species-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
            margin: 2rem 0;
            overflow: hidden;
        }
        .species-header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 2rem;
            text-align: center;
        }
        .species-title {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        .species-subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            font-style: italic;
        }
        .info-section {
            padding: 2rem;
        }
        .info-item {
            background: rgba(79, 172, 254, 0.1);
            border-left: 4px solid #4facfe;
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 0 10px 10px 0;
            transition: all 0.3s ease;
        }
        .info-item:hover {
            background: rgba(79, 172, 254, 0.2);
            transform: translateX(5px);
        }
        .info-label {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
        }
        .info-label i {
            margin-right: 0.5rem;
            color: #4facfe;
        }
        .info-value {
            color: #555;
            line-height: 1.6;
        }
        .image-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }
        .species-image {
            width: 100%;
            height: 200px;
            object-fit: cover;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s ease;
            cursor: pointer;
        }
        .species-image:hover {
            transform: scale(1.05);
        }
        .conservation-status {
            display: inline-block;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.9rem;
        }
        .status-low-risk { background: #d4edda; color: #155724; }
        .status-near-threatened { background: #fff3cd; color: #856404; }
        .status-vulnerable { background: #f8d7da; color: #721c24; }
        .status-endangered { background: #f5c6cb; color: #721c24; }
        .status-critically-endangered { background: #f1b0b7; color: #721c24; }
        .status-extinct { background: #d6d8db; color: #383d41; }
        .btn-back {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 25px;
            color: white;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        .btn-back:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            color: white;
        }
        .error-container {
            text-align: center;
            padding: 3rem;
            color: white;
        }
        .classification-tree {
            background: rgba(79, 172, 254, 0.05);
            border-radius: 10px;
            padding: 1rem;
            font-family: 'Courier New', monospace;
        }
        .modal-content {
            border-radius: 15px;
            border: none;
        }
        .modal-body {
            padding: 0;
        }
        .modal-image {
            width: 100%;
            height: auto;
            border-radius: 15px;
        }
    </style>
</head>
<body>
<div class="container-fluid">

    <!-- 物种详情页面 -->
    <div th:if="${species}" class="row justify-content-center">
        <div class="col-lg-10 col-xl-8">
            <div class="species-card">
                <!-- 头部信息 -->
                <div class="species-header">
                    <h1 class="species-title" th:text="${species.chineseName ?: '未知物种'}">中文名</h1>
                    <p class="species-subtitle" th:text="${species.scientificName}">学名</p>
                    <p class="species-subtitle" th:if="${species.commonName}" th:text="'俗名: ' + ${species.commonName}">俗名</p>
                </div>

                <!-- 详细信息 -->
                <div class="info-section">
                    <!-- 基本信息 -->
                    <div class="row">
                        <div class="col-md-6">
                            <div class="info-item" th:if="${species.scientificName}">
                                <div class="info-label">
                                    <i class="fas fa-microscope"></i>
                                    学名 (Scientific Name)
                                </div>
                                <div class="info-value" th:text="${species.scientificName}">学名</div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="info-item" th:if="${species.commonName}">
                                <div class="info-label">
                                    <i class="fas fa-comment"></i>
                                    俗名 (Common Name)
                                </div>
                                <div class="info-value" th:text="${species.commonName}">俗名</div>
                            </div>
                        </div>
                    </div>

                    <!-- 保护状状态 -->
                    <div th:if="${species.conservationStatus}" class="info-item">
                        <div class="info-label">
                            <i class="fas fa-shield-alt"></i>
                            保护状态 (Conservation Status)
                        </div>
                        <div class="info-value">
                                <span class="conservation-status" th:text="${species.conservationStatus}">
                                    保护状态
                                </span>
                        </div>
                    </div>

                    <!-- 分类信息 -->
                    <div th:if="${species.classification}" class="info-item">
                        <div class="info-label">
                            <i class="fas fa-sitemap"></i>
                            分类信息 (Classification)
                        </div>
                        <div class="info-value">
                            <div class="classification-tree" th:utext="${species.classification}">分类信息</div>
                        </div>
                    </div>

                    <!-- 形态特征 -->
                    <div class="row">
                        <div class="col-md-6">
                            <div th:if="${species.characteristics}" class="info-item">
                                <div class="info-label">
                                    <i class="fas fa-eye"></i>
                                    形态特征 (Characteristics)
                                </div>
                                <div class="info-value" th:text="${species.characteristics}">特征描述</div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div th:if="${species.sizeRange}" class="info-item">
                                <div class="info-label">
                                    <i class="fas fa-ruler"></i>
                                    体型范围 (Size Range)
                                </div>
                                <div class="info-value" th:text="${species.sizeRange}">体型范围</div>
                            </div>
                        </div>
                    </div>

                    <!-- 生态信息 -->
                    <div class="row">
                        <div class="col-md-6">
                            <div th:if="${species.habitat}" class="info-item">
                                <div class="info-label">
                                    <i class="fas fa-home"></i>
                                    栖息地 (Habitat)
                                </div>
                                <div class="info-value" th:text="${species.habitat}">栖息地描述</div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div th:if="${species.distribution}" class="info-item">
                                <div class="info-label">
                                    <i class="fas fa-globe"></i>
                                    分布区域 (Distribution)
                                </div>
                                <div class="info-value" th:text="${species.distribution}">分布区域</div>
                            </div>
                        </div>
                    </div>

                    <!-- 食性 -->
                    <div th:if="${species.diet}" class="info-item">
                        <div class="info-label">
                            <i class="fas fa-utensils"></i>
                            食性 (Diet)
                        </div>
                        <div class="info-value" th:text="${species.diet}">食性描述</div>
                    </div>

                    <!-- 详细描述 -->
                    <div th:if="${species.description}" class="info-item">
                        <div class="info-label">
                            <i class="fas fa-info-circle"></i>
                            详细描述 (Description)
                        </div>
                        <div class="info-value" th:utext="${#strings.replace(species.description, '\\n', '<br>')}">详细描述</div>
                    </div>

                    <!-- 图片展示 -->
                    <div th:if="${species.imageUrls}" class="info-item">
                        <div class="info-label">
                            <i class="fas fa-images"></i>
                            参考图片 (Reference Images)
                        </div>
                        <div class="image-gallery">
                            <!-- 这里需要在Controller中解析JSON数组 -->
                            <div th:each="imageUrl : ${imageUrlList}">
                                <img th:src="${imageUrl}"
                                     class="species-image"
                                     alt="物种图片"
                                     data-bs-toggle="modal"
                                     data-bs-target="#imageModal"
                                     th:onclick="'showImage(\'' + ${imageUrl} + '\')'">
                            </div>
                        </div>
                    </div>

                    <!-- 时间信息 -->
                    <div class="row mt-4">
                        <div class="col-md-6">
                            <div th:if="${species.createdTime}" class="info-item">
                                <div class="info-label">
                                    <i class="fas fa-calendar-plus"></i>
                                    创建时间
                                </div>
                                <div class="info-value" th:text="${#temporals.format(species.createdTime, 'yyyy-MM-dd HH:mm:ss')}">创建时间</div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div th:if="${species.updatedTime}" class="info-item">
                                <div class="info-label">
                                    <i class="fas fa-calendar-check"></i>
                                    更新时间
                                </div>
                                <div class="info-value" th:text="${#temporals.format(species.updatedTime, 'yyyy-MM-dd HH:mm:ss')}">更新时间</div>
                            </div>
                        </div>
                    </div>

                    <!-- 操作按钮 -->
                    <div class="text-center mt-4">
                        <a href="javascript:history.back()" class="btn btn-back me-3">
                            <i class="fas fa-arrow-left"></i> 返回上一页
                        </a>
                        <a href="/species/list" class="btn btn-back">
                            <i class="fas fa-list"></i> 返回列表
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- 图片模态框 -->
<div class="modal fade" id="imageModal" tabindex="-1" aria-labelledby="imageModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="imageModalLabel">物种图片</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <img id="modalImage" src="" class="modal-image" alt="物种图片">
            </div>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
<script>
    function showImage(imageUrl) {
        document.getElementById('modalImage').src = imageUrl;
    }

    // 页面加载完成后的初始化
    document.addEventListener('DOMContentLoaded', function() {
        // 为分类信息添加JSON格式化显示
        const classificationElements = document.querySelectorAll('.classification-tree');
        classificationElements.forEach(element => {
            try {
                const text = element.textContent;
                if (text.trim().startsWith('{') || text.trim().startsWith('[')) {
                    const jsonObj = JSON.parse(text);
                    element.innerHTML = '<pre>' + JSON.stringify(jsonObj, null, 2) + '</pre>';
                }
            } catch (e) {
                // 如果不是JSON格式，保持原样
            }
        });

        // 为长文本添加展开/收起功能
        const longTexts = document.querySelectorAll('.info-value');
        longTexts.forEach(element => {
            if (element.textContent.length > 200) {
                const fullText = element.textContent;
                const shortText = fullText.substring(0, 200) + '...';
                element.innerHTML = shortText +
                    '<br><a href="#" class="text-primary text-decoration-none" onclick="toggleText(this, \'' +
                    fullText.replace(/'/g, "\\'") + '\')">展开更多</a>';
            }
        });
    });

    function toggleText(link, fullText) {
        const parent = link.parentElement;
        if (link.textContent === '展开更多') {
            parent.innerHTML = fullText +
                '<br><a href="#" class="text-primary text-decoration-none" onclick="toggleText(this, \'' +
                fullText.replace(/'/g, "\\'") + '\')">收起</a>';
        } else {
            const shortText = fullText.substring(0, 200) + '...';
            parent.innerHTML = shortText +
                '<br><a href="#" class="text-primary text-decoration-none" onclick="toggleText(this, \'' +
                fullText.replace(/'/g, "\\'") + '\')">展开更多</a>';
        }
    }
</script>
</body>
</html>
~~~



## 核心代码详细解释

### 1. 页面结构与样式设计

#### 背景渐变设计



css

```css
body {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}
```

- 使用135度对角线渐变，从蓝紫色到深紫色
- 确保页面最小高度为100vh（视窗高度）
- 设置现代化字体栈

#### 毛玻璃效果卡片



css

```css
.species-card {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
    margin: 2rem 0;
    overflow: hidden;
}
```

- 使用半透明白色背景
- `backdrop-filter: blur(10px)` 创建毛玻璃效果
- 圆角边框和阴影提升视觉层次

### 2. Thymeleaf模板语法应用

#### 条件渲染



html

```html
<div th:if="${species}" class="row justify-content-center">
    <!-- 物种存在时才渲染内容 -->
</div>
```

#### 动态标题



html

```html
<title th:text="${species != null ? species.chineseName + ' - 海洋物种详情' : '海洋物种详情'}">
    海洋物种详情
</title>
```

- 使用三元运算符动态设置页面标题
- 如果物种存在，显示"物种名 - 海洋物种详情"

#### 文本内容绑定



html

```html
<h1 class="species-title" th:text="${species.chineseName ?: '未知物种'}">中文名</h1>
<p class="species-subtitle" th:text="${species.scientificName}">学名</p>
```

- `?:` 是Elvis操作符，提供默认值
- 当`chineseName`为null时显示"未知物种"

### 3. 信息展示模块

#### 信息项结构



html

```html
<div class="info-item" th:if="${species.scientificName}">
    <div class="info-label">
        <i class="fas fa-microscope"></i>
        学名 (Scientific Name)
    </div>
    <div class="info-value" th:text="${species.scientificName}">学名</div>
</div>
```

- 每个信息项都有条件渲染
- 包含图标、标签和值三部分
- 使用Font Awesome图标增强视觉效果

#### 保护状态样式化



html

```html
<span class="conservation-status" th:text="${species.conservationStatus}">
    保护状态
</span>
```

配合CSS类实现不同保护状态的颜色区分：



css

```css
.status-low-risk { background: #d4edda; color: #155724; }
.status-endangered { background: #f5c6cb; color: #721c24; }
```

### 4. 图片展示功能

#### 图片网格布局



html

```html
<div class="image-gallery">
    <div th:each="imageUrl : ${imageUrlList}">
        <img th:src="${imageUrl}"
             class="species-image"
             alt="物种图片"
             data-bs-toggle="modal"
             data-bs-target="#imageModal"
             th:onclick="'showImage(\'' + ${imageUrl} + '\')'">
    </div>
</div>
```

- 使用`th:each`遍历图片URL列表
- 每个图片都绑定模态框展示功能
- 动态生成JavaScript调用

#### 图片网格CSS



css

```css
.image-gallery {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 1rem;
}
```

- 使用CSS Grid自适应布局
- 每列最小200px，自动填充
- 统一间距1rem

### 5. 交互功能实现

#### 模态框图片查看



javascript

```javascript
function showImage(imageUrl) {
    document.getElementById('modalImage').src = imageUrl;
}
```

- 点击缩略图时更新模态框中的图片源
- 配合Bootstrap模态框组件

#### 长文本展开/收起



javascript

```javascript
function toggleText(link, fullText) {
    const parent = link.parentElement;
    if (link.textContent === '展开更多') {
        parent.innerHTML = fullText + 
            '<br><a href="#" onclick="toggleText(this, ...)">收起</a>';
    } else {
        const shortText = fullText.substring(0, 200) + '...';
        parent.innerHTML = shortText + 
            '<br><a href="#" onclick="toggleText(this, ...)">展开更多</a>';
    }
}
```

- 动态切换文本显示长度
- 超过200字符自动截断并添加展开链接

#### JSON数据格式化



javascript

```javascript
const classificationElements = document.querySelectorAll('.classification-tree');
classificationElements.forEach(element => {
    try {
        const text = element.textContent;
        if (text.trim().startsWith('{') || text.trim().startsWith('[')) {
            const jsonObj = JSON.parse(text);
            element.innerHTML = '<pre>' + JSON.stringify(jsonObj, null, 2) + '</pre>';
        }
    } catch (e) {
        // 如果不是JSON格式，保持原样
    }
});
```

- 自动检测并格式化JSON数据
- 使用`<pre>`标签保持格式

### 6. 响应式设计

#### Bootstrap网格系统



html

```html
<div class="row">
    <div class="col-md-6">
        <!-- 中等及以上屏幕占一半宽度 -->
    </div>
    <div class="col-md-6">
        <!-- 小屏幕堆叠显示 -->
    </div>
</div>
```

#### 容器尺寸控制



html

```html
<div class="col-lg-10 col-xl-8">
    <!-- 大屏幕占10/12，超大屏幕占8/12 -->
</div>
```

### 7. 用户体验优化

#### 悬停效果



css

```css
.info-item:hover {
    background: rgba(79, 172, 254, 0.2);
    transform: translateX(5px);
}
```

- 鼠标悬停时改变背景色
- 添加平移动画效果

#### 按钮动画



css

```css
.btn-back:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}
```

- 悬停时按钮上浮效果
- 增加阴影深度

技术特点

1. **模板引擎**：使用Thymeleaf进行服务端渲染
2. **CSS框架**：Bootstrap 5提供响应式基础
3. **图标库**：Font Awesome提供丰富图标
4. **现代CSS**：使用Grid、Flexbox、渐变、毛玻璃等
5. **渐进增强**：基础功能不依赖JavaScript，增强功能用JS实现
6. **用户体验**：丰富的动画效果和交互反馈

适用场景

- 海洋生物学研究平台
- 科普教育网站
- 生物多样性数据库
- 自然保护组织网站
- 学术研究展示平台